\section{Abstract} % 150-250słów, polski + angielski
A Python particle-in-cell plasma simulation code is developed to model the interaction between a hydrogen plasma target
and a laser impulse. The code is then optimized to demonstrate the possibilities of using a high level programming
language to call low level numerical procedures, thus achieving high computational efficiency.

\section{Streszczenie}
Utworzono kod symulacyjny Particle-in-Cell mający modelować interakcję relatywistycznej plazmy wodorowej oraz
impulsu laserowego. Kod zoptymalizowano w celu zademonstrowania możliwości użycia wysokopoziomowego języka programowania
wywołującego niskopoziomowe procedury numeryczne do osiągnięcia wysokiej wydajności obliczeniowej.

\section{Wstęp} %2-3 strony wprowadzenie w temat, motywacja, teza (cel)
Algorytmy Particle-in-Cell ("cząstka w komórce") to jedne z najbardziej zbliżonych do fundamentalnej fizyki
metod symulacji materii w stanie plazmy. Zastosowany w nich lagranżowski opis cząsteczek pozwala na dokładne
odwzorowanie dynamiki ruchu elektronów i jonów. Jednocześnie, ewolucja pola elektromagnetycznego na Eulerowskiej
siatce dokonywana zamiast bezpośredniego obliczania oddziaływań międzycząsteczkowych pozwala na znaczące
przyspieszenie etapu obliczenia oddziaływań międzycząsteczkowych. W większości symulacji cząsteczkowych właśnie
ten etap jest najbardziej krytyczny dla wydajności progamu.

W ostatnich czasach symulacje Particle-in-Cell zostały wykorzystane m.in. do
\item symulacji przewidywanej turbulencji plazmy w reaktorze termojądrowym ITER %DOCUMENTATION: źródło,
\item modelowania rekonekcji linii magnetycznych w polu gwiazdy %DOCUMENTATION: źródło
\item projektowania silników jonowych (Halla) %DOCUMENTATION: jak wyżej
\item badania interakcji laserów z plazmą w kontekście tworzenia niewielkich akceleratorów cząstek %DOCUMENTATION

Należy zauważyć, że w świetle rosnącej dostępności silnie równoległej mocy obliczeniowej w postaci kart graficznych %DOCUMENTATION
możliwości algorytmów Particle-in-Cell będą rosły współmiernie, co może pozwolić na rozszerzenie ich zastosowań.
Inżynieria oprogramowania zorientowanego na wykorzystanie możliwości kart graficznych jest jednak utrudniona poprzez
niskopoziomowość %DOCUMENTATION: to sformułowanie zabiło JFK i chciałbym inne
istniejących technologii (CUDA, OpenCL) %DOCUMENTATION: źródło
co utrudnia pisanie złożonych programów, zwłaszcza przez osoby zajmujące się głównie pracą badawczą
niż wyłącznie programowaniem. %DOCUMENTATION: przeformułować

Niniejsza praca ma na celu utworzenie kodu symulacyjnego wykorzystującego metodę Particle-in-Cell w języku
wysokopoziomowym i %wyciśnięcie z niego tylu flopsów ile się da!
Ma to dwojaki sens:
1. zweryfikowanie możliwości leżących w obecnych językach wysokopoziomowych bez wykorzystywania kart graficznych

\section{Część analityczno-teoretyczna} % 30% pracy - opis problematyki podjętego tematu w zakresie wykorzystanym w pracy i analizie

\subsection{Symulacja plazmy}

\subsection{Modele Particle-in-cell}

Algorytm particle-in-cell składa się z czterech elementów % GRAFIKA: cykliczny schemacik
1. GATHER
depozycja ładunku oraz prądu z położeń cząstek do lokacji na dyskretnej siatce poprzez interpolację,
co pozwala na sprawne rozwiązanie na tej siatce
równań Maxwella jako układu różnicowych równań cząstkowych zamiast obliczania skalujących się kwadratowo w liczbie cząstek
oddziaływań kulombowskich między nimi.
2. SOLVE
Sprawne rozwiązanie Maxwella na dyskretnej, Eulerowskiej siatce; znalezienie pól elektrycznego i magnetycznego
na podstawie gęstości ładunku i prądu na siatce. 
3. SCATTER
Interpolacja pól z siatki do lokacji cząstek, co pozwala określić siły elektromagnetyczne działające na cząstki.
4. PUSH
iteracja równań ruchu cząstek na podstawie ich prędkości (aktualizacja położeń)
oraz działających na nie sił elektromagnetycznych (aktualizacja prędkości).

\subsubsection{Makrocząstki}
Należy zauważyć, że obecnie nie jest możliwe dokładne odwzorowanie dynamiki układów plazmowych w sensie interakcji
między poszczególnymi cząstkami ze względu na liczbę cząstek % rzędu liczby Avogadro ~10^23
W tym kontekście bardzo szczęśliwym jest fakt, że wszystkie istotne wielkości zależą nie od ładunku ani masy,
ale od stosunku $q/m$. W praktyce stosuje się więc \emph{makrocząstki}, obdarzone ładunkiem i masą będące wielokrotnościami
tych wielkości dla cząstek występujących w naturze (jak jony i elektrony, pozwalając jednocześnie zachować gęstości
cząstek i ładunku % oraz inne wielkości fizyczne)
zbliżone do rzeczywistych.

\subsection{Python}
Python jest wysokopoziomowym, interpretowanym językiem programowania, którego atutami są szybkie prototypowanie,

Python znajduje zastosowania w analizie danych, uczeniu maszynowym (zwłaszcza w astronomii). W zakresie symulacji
w ostatnich czasach powstały kody skalujące się nawet w zakres superkomputerów, np. w mechanice płynów % DOCUMENTATION: PyFR

Atutem Pythona w wysokowydajnych obliczeniach jest łatwość wywoływania w nim zewnętrznych bibliotek napisanych
na przykład w C lub Fortranie, co pozwala na osiągnięcie podobnych rezultatów wydajnościowych jak dla kodów
napisanych w C.

\subsection{Optymalizacja kodu}

\section{Opis i treść kodu} % 20-30% - opis przyjętych rozwiązań i uzasadnienie ich wyboru
Cały kod programu w celu reprodukowalności wyników tworzony był i jest dostępny na platformie Github %link

\subsection{Struktura i hierarchia kodu}

Program ma obiektową strukturę zewnątrzą, którą w celu łatwości zrozumienia jego działania nakrywa wewnętrzną warstwę
składającą się głównie z n-wymiarowych tablic \emph{NumPy} oraz zwektoryzowanych operacji na nich.

Kod składa się z kilku prostych koncepcyjnie elementów:

\subsubsection{Species}
Klasa reprezentująca pewną grupę cząstek (np. elektrony w symulacji)

\subsubsection{Grid}
Klasa reprezentująca dyskretną siatkę, na której dokonywane są obliczenia dot. pól elektromagnetycznych.

\subsubsection{Simulation}
Klasa zbierająca w całość Grid oraz dowolną liczbę Species zawartych w symulacji, jak również
pozwalająca w prosty sposób na wykonywanie iteracji algorytmu i analizy danych. Jest tworzona tak przy
uruchamianiu symulacji, jak i przy wczytywaniu danych z plików .hdf5.

\subsubsection{Pliki pomocnicze}
Poza powyższymi program jest podzielony na pliki:
*algorithms_grid - zawiera algorytmy dot. rozwiązywania równań Maxwella na dyskretnej siatce
*algorithms_interpolation - zawiera algorytmy dot. interpolacji z cząstek na siatkę i odwrotnie
*algorithms_pusher - zawiera algorytmy integrujące numerycznie równania ruchu cząstek
*animation - tworzy animacje dla celów analizy danych
*static_plots - tworzy statyczne wykresy dla celów analizy danych
*Plotting.py - zawiera ustawienia dot. analizy danych % czy to można przenieść do simulation czy gdzieś?

Configi testowe są zawarte w plikach run_*: % przeformułować
* run_coldplasma
* run_twostream
* run_wave
* run_beam

Testy jednostkowe są zawarte w katalogu tests:

\subsection{Wybrane algorytmy}

% LEAPFROG
Należy zauważyć, że w inicjalizacyjnej iteracji algorytmu pomija się przesunięcie cząstek w przestrzeni, aktualizując jedynie
prędkości. Krok czasowy jest wtedy ustawiany na minus połowę swojej zwykłej wartości, co pozwala na obliczenia
z wykorzystaniem prędkości znanej w połowie kroku czasowego między kolejnymi iteracjami czasowymi. Jest to tzw. algorytm
leapfrog % reference
stosowany tam, gdzie potrzebna jest długofalowa stałość energii symulacji. Wynika to z symplektyczności % poczytać
tego rodzaju integratorów równań ruchu (w przeciwieństwie do, na przykład, standardowej metody Runge-Kutta 4, która
mimo swej większej dokładności nie zachowuje energii cząstek.

# Implementacje poszczególnych części algorytmów

Ewolucja pola elektromagnetycznego opisana jest poprzez równania Maxwella. Jak pokazują Buneman i Ville % nazwisko
numerycznie można zastosować dwa główne podejścia: % zredagować
1. wykorzystać równania na dywergencję pola (prawa Gaussa) do rozwiązania pola na całej siatce. Niestety, jest to
algorytm inherentnie globalny, w którym informacja o warunkach brzegowych jest konieczna w każdym oczku siatki
% alternatywa na słowo "oczko"?
2. wykorzystać równania na rotację pola (prawa Ampera i Faradaya), opisujące ewolucję czasową pól. Jak łatwo pokazać (Buneman),
dywergencja pola elektrycznego oraz magnetycznego nie zmienia się w czasie pod wpływem tak opisanej ewolucji czasowej:

Co za tym idzie, jeżeli rozpoczniemy symulację od znalezienia pola na podstawie warunków brzegowych i początkowych (gęstości
ładunku), możemy już dalej iterować pole na podstawie równań rotacji. Ma to dwie znaczące zalety:
* algorytm ewolucji pola staje się trywialny, zwłaszcza w 1D - ogranicza się do elementarnego dodawania i mnożenia %poprawić
* algorytm ewolucji pola staje się lokalny (do znalezienia wartości pola w danym oczku w kolejnej iteracji wykorzystujemy
jedynie informacje zawarte w tym właśnie oczku i potencjalnie jego sąsiadach % jak to faktycznie wygląda z tym algo?
co zapobiega problemowi informacji przebiegającej w symulacji szybciej niż światło oraz zapewnia stabilność na podstawie
warunku Couranta.
\subsection{Implementacja podstawowych algorytmów numerycznych stosowanych w symulacji}
\subsection{Wykorzystane techniki i technologie}
# Zastosowane technologie
* obliczenia wektorowe
* pytest; Test-driven development
* format plików danych hdf5
* wykresy: matplotlib
* scipy
* numba
* numpy

Przy pracy nad kodem użyto frameworku testowego pytest %link w stopce
Obsługa testów jest trywialna:

Należy zaznaczyć, że w numeryce testy jednostkowe potrafią zaoszczędzić bardzo dużo czasu na polowaniach na bugi
poprzez automatyzację uruchamiania kolejnych partii kodu. Dobrze napisane testy są praktycznie koniecznością w dzisiejszych
czasach. % trochę soapbox?
% przykład kodu
% powinienem mieć coś w stylu make test czy setup.py test

* Numba
Innym podejściem do optymalizacji kodu napisanego w Pythonie jest kompilacja Just-In-Time, polegająca na % DOCUMENTATION: JIT


\section{Część weryfikacyjna} % 30-40% - opis wyników, analiza, weryfikacja i porównanie do danych literaturowych
\subsection{Przypadki testowe - porównanie z LPIC++}
\subsection{Benchmarki - szybkość, zasobożerność} %fix
\subsection{Problemy napotkane w trakcie pisania kodu}
\section{Zakończenie} % 3-5 stron
\section{Bibliografia} % 15-25 pozycji
1. Birdsall, Langdon
2. LPIC++
3. Buneman, Villasenor
4. Metody numeryczne


