Algorytmy Particle-in-Cell ("cząstka w komórce") to jedne z najbardziej zbliżonych do fundamentalnej fizyki
metod symulacji materii w stanie plazmy. Zastosowany w nich lagranżowski opis cząsteczek pozwala na dokładne
odwzorowanie dynamiki ruchu elektronów i jonów. Jednocześnie, ewolucja pola elektromagnetycznego na Eulerowskiej
siatce dokonywana zamiast bezpośredniego obliczania oddziaływań międzycząsteczkowych pozwala na znaczące
przyspieszenie etapu obliczenia oddziaływań międzycząsteczkowych. W większości symulacji cząsteczkowych właśnie
ten etap jest najbardziej krytyczny dla wydajności progamu.

W ostatnich czasach symulacje Particle-in-Cell zostały wykorzystane m.in. do
\item symulacji przewidywanej turbulencji plazmy w reaktorze termojądrowym ITER %DOCUMENTATION: źródło,
\item modelowania rekonekcji linii magnetycznych w polu gwiazdy %DOCUMENTATION: źródło
\item projektowania silników jonowych (Halla) %DOCUMENTATION: jak wyżej
\item badania interakcji laserów z plazmą w kontekście tworzenia niewielkich akceleratorów cząstek %DOCUMENTATION

Należy zauważyć, że w świetle rosnącej dostępności silnie równoległej mocy obliczeniowej w postaci kart graficznych %DOCUMENTATION
możliwości algorytmów Particle-in-Cell będą rosły współmiernie, co może pozwolić na rozszerzenie ich zastosowań.
Inżynieria oprogramowania zorientowanego na wykorzystanie możliwości kart graficznych jest jednak utrudniona poprzez
niskopoziomowość %DOCUMENTATION: to sformułowanie zabiło JFK i chciałbym inne
istniejących technologii (CUDA, OpenGL) %DOCUMENTATION: źródło
co utrudnia pisanie złożonych programów, zwłaszcza przez osoby zajmujące się głównie pracą badawczą
niż wyłącznie programowaniem. %DOCUMENTATION: przeformułować

Niniejsza praca ma na celu utworzenie kodu symulacyjnego wykorzystującego metodę Particle-in-Cell w języku
wysokopoziomowym i %wyciśnięcie z niego tylu flopsów ile się da!
Ma to dwojaki sens:
1. zweryfikowanie możliwości leżących w obecnych językach wysokopoziomowych bez wykorzystywania kart graficznych

Python jest wysokopoziomowym, interpretowanym językiem programowania, którego atutami są szybkie prototypowanie,

Python znajduje zastosowania w analizie danych, uczeniu maszynowym (zwłaszcza w astronomii). W zakresie symulacji
w ostatnich czasach powstały kody skalujące się nawet w zakres superkomputerów, np. w mechanice płynów % DOCUMENTATION: PyFR

Atutem Pythona w wysokowydajnych obliczeniach jest łatwość wywoływania w nim zewnętrznych bibliotek napisanych
na przykład w C lub Fortranie, co pozwala na osiągnięcie podobnych rezultatów wydajnościowych jak dla kodów
napisanych w C.

# Algorytm Particle-in-cell

składa się z czterech elementów
1. PUSH
2. GATHER
3. SOLVE
4. SCATTER

# Implementacje poszczególnych części algorytmów

Ewolucja pola elektromagnetycznego opisana jest poprzez równania Maxwella. Jak pokazują Buneman i Ville % nazwisko
numerycznie można zastosować dwa główne podejścia: % zredagować
1. wykorzystać równania na dywergencję pola (prawa Gaussa) do rozwiązania pola na całej siatce. Niestety, jest to
algorytm inherentnie globalny, w którym informacja o warunkach brzegowych jest konieczna w każdym oczku siatki
% alternatywa na słowo "oczko"?
2. wykorzystać równania na rotację pola (prawa Ampera i Faradaya), opisujące ewolucję czasową pól. Jak łatwo pokazać (Buneman),
dywergencja pola elektrycznego oraz magnetycznego nie zmienia się w czasie pod wpływem tak opisanej ewolucji czasowej:

Co za tym idzie, jeżeli rozpoczniemy symulację od znalezienia pola na podstawie warunków brzegowych i początkowych (gęstości
ładunku), możemy już dalej iterować pole na podstawie równań rotacji. Ma to dwie znaczące zalety:
* algorytm ewolucji pola staje się trywialny, zwłaszcza w 1D - ogranicza się do elementarnego dodawania i mnożenia %poprawić
* algorytm ewolucji pola staje się lokalny (do znalezienia wartości pola w danym oczku w kolejnej iteracji wykorzystujemy
jedynie informacje zawarte w tym właśnie oczku i potencjalnie jego sąsiadach % jak to faktycznie wygląda z tym algo?
co zapobiega problemowi informacji przebiegającej w symulacji szybciej niż światło oraz zapewnia stabilność na podstawie
warunku Couranta.

# Zastosowane technologie
* obliczenia wektorowe
* pytest; Test-driven development

Przy pracy nad kodem użyto frameworku testowego pytest %link w stopce
Obsługa testów jest trywialna:

Należy zaznaczyć, że w numeryce testy jednostkowe potrafią zaoszczędzić bardzo dużo czasu na polowaniach na bugi
poprzez automatyzację uruchamiania kolejnych partii kodu. Dobrze napisane testy są praktycznie koniecznością w dzisiejszych
czasach. % trochę soapbox?
% przykład kodu
% powinienem mieć coś w stylu make test czy setup.py test

* Numba
Innym podejściem do optymalizacji kodu napisanego w Pythonie jest kompilacja Just-In-Time, polegająca na % DOCUMENTATION: JIT

