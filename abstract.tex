\section{Abstract} % 150-250słów, polski + angielski
A Python particle-in-cell plasma simulation code is developed to model the interaction between a hydrogen plasma target
and a laser impulse. The code is then optimized to demonstrate the possibilities of using a high level programming
language to call low level numerical procedures, thus achieving high computational efficiency.

\section{Streszczenie}
Utworzono kod symulacyjny Particle-in-Cell mający modelować interakcję relatywistycznej plazmy wodorowej oraz
impulsu laserowego. Kod zoptymalizowano w celu zademonstrowania możliwości użycia wysokopoziomowego języka programowania
wywołującego niskopoziomowe procedury numeryczne do osiągnięcia wysokiej wydajności obliczeniowej.

\section{Wstęp} %2-3 strony wprowadzenie w temat, motywacja, teza (cel)
Algorytmy Particle-in-Cell ("cząstka w komórce") to jedne z najbardziej zbliżonych do fundamentalnej fizyki
metod symulacji materii w stanie plazmy. Zastosowany w nich lagranżowski opis cząsteczek pozwala na dokładne
odwzorowanie dynamiki ruchu elektronów i jonów. Jednocześnie, ewolucja pola elektromagnetycznego na Eulerowskiej
siatce dokonywana zamiast bezpośredniego obliczania oddziaływań międzycząsteczkowych pozwala na znaczące
przyspieszenie etapu obliczenia oddziaływań międzycząsteczkowych. W większości symulacji cząsteczkowych właśnie
ten etap jest najbardziej krytyczny dla wydajności progamu.

W ostatnich czasach symulacje Particle-in-Cell zostały wykorzystane m.in. do
\item symulacji przewidywanej turbulencji plazmy w reaktorze termojądrowym ITER %TODO: źródło,
\item modelowania rekonekcji linii magnetycznych w polu gwiazdy %TODO: źródło
\item projektowania silników jonowych (Halla) %TODO: jak wyżej
\item badania interakcji laserów z plazmą w kontekście tworzenia niewielkich akceleratorów cząstek %TODO

Należy zauważyć, że w świetle rosnącej dostępności silnie równoległej mocy obliczeniowej w postaci kart graficznych %TODO
możliwości algorytmów Particle-in-Cell będą rosły współmiernie, co może pozwolić na rozszerzenie ich zastosowań.
Inżynieria oprogramowania zorientowanego na wykorzystanie możliwości kart graficznych jest jednak utrudniona poprzez
niskopoziomowość %TODO: to sformułowanie zabiło JFK i chciałbym inne
istniejących technologii (CUDA, OpenCL) %TODO: źródło
co utrudnia pisanie złożonych programów, zwłaszcza przez osoby zajmujące się głównie pracą badawczą
niż wyłącznie programowaniem. %TODO: przeformułować

Niniejsza praca ma na celu utworzenie kodu symulacyjnego wykorzystującego metodę Particle-in-Cell w języku
wysokopoziomowym i %wyciśnięcie z niego tylu flopsów ile się da!
Ma to dwojaki sens:
1. zweryfikowanie możliwości leżących w obecnych językach wysokopoziomowych bez wykorzystywania kart graficznych

\section{Część analityczno-teoretyczna} % 30% pracy - opis problematyki podjętego tematu w zakresie wykorzystanym w pracy i analizie

\subsection{Fizyka plazmy}

Plazma, powszechnie nazywana czwartym stanem materii, to zbiór zjonizowanych %TODO: formalna definicja plazmy
cząstek oraz elektronów. Plazmy występują w całym wszechświecie, od materii międzygwiezdnej po błyskawice.
Ich istnienie uwarunkowane jest obecnością wysokich energii, wystarczających do zjonizowania atomów gazu.

Fizyka plazmy jest stosunkowo młodą nauką, której rozwój nastąpił dopiero w ostatnim stuleciu, zaczynając od badań Alfvena. %TODO reference
Globalny wzrost zainteresowania fizyką plazmy rozpoczął się w latach '50 ubiegłego wieku, %TODO - zweryfikować
gdy uświadomiono sobie, że można zastosować ją do przeprowadzania kontrolowanych reakcji syntezy jądrowej, % TODO: reference: fusion in europe history of fusion
które mogą mieć zastosowania w energetyce jako następny etap rozwoju po reakcjach rozpadu wykorzystywanych
w "klasycznych" elektrowniach jądrowych. 

Poza tym plazmy mają szerokie zastosowanie w przemyśle metalurgicznym, elektronicznym, kosmicznym itp. %TODO: to potrzebuje źródła

\subsection{Modelowanie i symulacja plazmy}

Zjawiska z zakresu fizyki plazmy są jednymi z bardziej złożonych problemów modelowanie komputerowej.
Głównym, koncepcyjnie, powodem uniemożliwiającym zastosowanie prostych metod symulacji
znanych z newtonowskiej dynamiki molekularnej jest mnogość oddziaływań - każda cząstka oddziałowuje
z każdą inną nawzajem poprzez niepomijalne na dużych odległościach oddziaływania kulombowskie $\approx r^{-2}$.

Z powodu dużej liczby cząstek w układach plazmowych, jedynymi praktycznymi podejściami są opisy statystyczne, opierające się na
modelach kinetycznych. Wielkością opisującą plazmę jest tu funkcja dystrybucji

\begin{equation}
f(\vec{x}, \vec{v}, t)
\end{equation}

opisująca gęstość rozkładu plazmy w sześciowymiarowej przestrzeni fazowej (po trzy wymiary na położenia oraz prędkości).

Podstawowym równaniem statystycznym opisującym plazmę jest równanie Vlasova % TODO: może zacząć od Klimontowicza, jest wyprowadzalne z niego

\begin{equation}
\f_\alpha 
% TODO: wzór na równanie Vlasova
\end{equation}

W praktyce jest ono również nierozwiązywalne. Jednym z powodów jest koniecznośc uzyskania dobrej rozdzielczości prędkości
przy jednoczesnym zachowaniu zakresów obejmujących prędkości relatywistyczne. % TODO: runaway electrons

W modelowaniu komputerowym plazmy stosuje się dwa główne podejścia:
\begin{enumerate}
\item modele płynowe oparte na ciągłym opisie plazmy poprzez uśrednienie po dystrybucji
wielkości termodynamicznych, co daje modele takie jak magnetohydrodynamikę %TODO: reformulate
\item modele dyskretne oparte na samplowaniu dystrybucji plazmy przy użyciu dyskretnych cząstek
\end{enumerate}

Prawdopodobnie najpopoularniejszym modelem z tej drugeij kategorii są modele Particle-in-cell.

\subsection{Modele Particle-in-cell}

Idea modelu particle-in-cell jest wyjątkowo prosta i opiera się na idei przyspieszenia najbardziej złożonego obliczeniowo kroku
symulacji dynamiki molekularnej, czyli obliczania sił międzycząsteczkowych. Cząstki poruszają się w ciągłej, Lagrange'owskiej przestrzeni.
Ich ruch wykorzystywany jest do zebrania informacji dotyczącej gęstości ładunku i prądu na dyskretną, Eulerowską siatkę. Na siatce rozwiązane
są (jako równania różniczkowe cząstkowe) równania Maxwella, dzięki którym otrzymuje się pola elektryczne i magnetyczne, które z powrotem są przekazane
do położeń cząstek. Obliczeniowo, uwzględniając koszty odpowiednich interpolacji, pozwala to zredukować złożoność kroku obliczenia sił międzycząsteczkowych
do $n \log{n}$ z $n^2$ % TODO: wyrazić złożoność PIC przez rozmiar siatki

Algorytm particle-in-cell składa się z czterech elementów % GRAFIKA: cykliczny schemacik
\begin{enumerate}
\item GATHER \\
depozycja ładunku oraz prądu z położeń cząstek do lokacji na dyskretnej siatce poprzez interpolację,
co pozwala na sprawne rozwiązanie na tej siatce
równań Maxwella jako układu różnicowych równań cząstkowych zamiast obliczania skalujących się kwadratowo w liczbie cząstek
oddziaływań kulombowskich między nimi.
\item SOLVE \\
Sprawne rozwiązanie Maxwella na dyskretnej, Eulerowskiej siatce; znalezienie pól elektrycznego i magnetycznego
na podstawie gęstości ładunku i prądu na siatce. 
\item SCATTER \\
Interpolacja pól z siatki do lokacji cząstek, co pozwala określić siły elektromagnetyczne działające na cząstki.
\item PUSH \\
iteracja równań ruchu cząstek na podstawie ich prędkości (aktualizacja położeń)
oraz działających na nie sił elektromagnetycznych (aktualizacja prędkości).

\subsubsection{Makrocząstki}
Należy zauważyć, że obecnie nie jest możliwe dokładne odwzorowanie dynamiki układów plazmowych w sensie interakcji
między poszczególnymi cząstkami ze względu na liczbę cząstek % rzędu liczby Avogadro ~10^23
W tym kontekście bardzo szczęśliwym jest fakt, że wszystkie istotne wielkości zależą nie od ładunku ani masy,
ale od stosunku $q/m$. W praktyce stosuje się więc \emph{makrocząstki}, obdarzone ładunkiem i masą będące wielokrotnościami
tych wielkości dla cząstek występujących w naturze (jak jony i elektrony, pozwalając jednocześnie zachować gęstości
cząstek i ładunku % oraz inne wielkości fizyczne)
zbliżone do rzeczywistych.

\subsection{Problem testowy}

Problemem testowym, jakiego używamy do przetestowania wydajności działania algorytmu jest
interakcja impulsu laserowego z tarczą składającą się ze zjonizowanego wodoru i elektronów.

Układ ten modelowany jest jako jednowymiarowy.

Jest to tak zwany w literaturze model 1D-3D. O ile położenia cząstek są jednowymiarowe


\subsection{Python}
Python jest wysokopoziomowym, interpretowanym językiem programowania, którego atutami są szybkie prototypowanie,

Python znajduje zastosowania w analizie danych, uczeniu maszynowym (zwłaszcza w astronomii). W zakresie symulacji
w ostatnich czasach powstały kody skalujące się nawet w zakres superkomputerów, np. w mechanice płynów % TODO: PyFR

Atutem Pythona w wysokowydajnych obliczeniach jest łatwość wywoływania w nim zewnętrznych bibliotek napisanych
na przykład w C lub Fortranie, co pozwala na osiągnięcie podobnych rezultatów wydajnościowych jak dla kodów
napisanych w C.

\subsection{Optymalizacja kodu}

\section{Opis i treść kodu} % 20-30% - opis przyjętych rozwiązań i uzasadnienie ich wyboru
Cały kod programu w celu reprodukowalności wyników tworzony był i jest dostępny na platformie Github %link

\subsection{Struktura i hierarchia kodu}

Program ma obiektową strukturę zewnątrzą, którą w celu łatwości zrozumienia jego działania nakrywa wewnętrzną warstwę
składającą się głównie z n-wymiarowych tablic \emph{NumPy} oraz zwektoryzowanych operacji na nich.

Kod składa się z kilku prostych koncepcyjnie elementów:

\subsubsection{Species}
Klasa reprezentująca pewną grupę cząstek (np. elektrony w symulacji)

\subsubsection{Grid}
Klasa reprezentująca dyskretną siatkę, na której dokonywane są obliczenia dot. pól elektromagnetycznych.

\subsubsection{Simulation}
Klasa zbierająca w całość Grid oraz dowolną liczbę Species zawartych w symulacji, jak również
pozwalająca w prosty sposób na wykonywanie iteracji algorytmu i analizy danych. Jest tworzona tak przy
uruchamianiu symulacji, jak i przy wczytywaniu danych z plików .hdf5.

\subsubsection{Pliki pomocnicze}
Poza powyższymi program jest podzielony na pliki:
*algorithms_grid - zawiera algorytmy dot. rozwiązywania równań Maxwella na dyskretnej siatce
*algorithms_interpolation - zawiera algorytmy dot. interpolacji z cząstek na siatkę i odwrotnie
*algorithms_pusher - zawiera algorytmy integrujące numerycznie równania ruchu cząstek
*animation - tworzy animacje dla celów analizy danych
*static_plots - tworzy statyczne wykresy dla celów analizy danych
*Plotting.py - zawiera ustawienia dot. analizy danych % czy to można przenieść do simulation czy gdzieś?

Configi testowe są zawarte w plikach run_*: % przeformułować
* run_coldplasma
* run_twostream
* run_wave
* run_beam

Testy jednostkowe są zawarte w katalogu tests:

\subsection{Wybrane algorytmy}

% LEAPFROG
Należy zauważyć, że w inicjalizacyjnej iteracji algorytmu pomija się przesunięcie cząstek w przestrzeni, aktualizując jedynie
prędkości. Krok czasowy jest wtedy ustawiany na minus połowę swojej zwykłej wartości, co pozwala na obliczenia
z wykorzystaniem prędkości znanej w połowie kroku czasowego między kolejnymi iteracjami czasowymi. Jest to tzw. algorytm
leapfrog % reference
stosowany tam, gdzie potrzebna jest długofalowa stałość energii symulacji. Wynika to z symplektyczności % poczytać
tego rodzaju integratorów równań ruchu (w przeciwieństwie do, na przykład, standardowej metody Runge-Kutta 4, która
mimo swej większej dokładności nie zachowuje energii cząstek.

# Implementacje poszczególnych części algorytmów

Ewolucja pola elektromagnetycznego opisana jest poprzez równania Maxwella. Jak pokazują Buneman i Ville % nazwisko
numerycznie można zastosować dwa główne podejścia: % zredagować
1. wykorzystać równania na dywergencję pola (prawa Gaussa) do rozwiązania pola na całej siatce. Niestety, jest to
algorytm inherentnie globalny, w którym informacja o warunkach brzegowych jest konieczna w każdym oczku siatki
% alternatywa na słowo "oczko"?
2. wykorzystać równania na rotację pola (prawa Ampera i Faradaya), opisujące ewolucję czasową pól. Jak łatwo pokazać (Buneman),
dywergencja pola elektrycznego oraz magnetycznego nie zmienia się w czasie pod wpływem tak opisanej ewolucji czasowej:

Co za tym idzie, jeżeli rozpoczniemy symulację od znalezienia pola na podstawie warunków brzegowych i początkowych (gęstości
ładunku), możemy już dalej iterować pole na podstawie równań rotacji. Ma to dwie znaczące zalety:
* algorytm ewolucji pola staje się trywialny, zwłaszcza w 1D - ogranicza się do elementarnego dodawania i mnożenia %poprawić
* algorytm ewolucji pola staje się lokalny (do znalezienia wartości pola w danym oczku w kolejnej iteracji wykorzystujemy
jedynie informacje zawarte w tym właśnie oczku i potencjalnie jego sąsiadach % jak to faktycznie wygląda z tym algo?
co zapobiega problemowi informacji przebiegającej w symulacji szybciej niż światło oraz zapewnia stabilność na podstawie
warunku Couranta.
\subsection{Implementacja podstawowych algorytmów numerycznych stosowanych w symulacji}
\subsection{Wykorzystane techniki i technologie}
# Zastosowane technologie
* obliczenia wektorowe
* pytest; Test-driven development
* format plików danych hdf5
* wykresy: matplotlib
* scipy
* numba
* numpy

Przy pracy nad kodem użyto frameworku testowego pytest %link w stopce
Obsługa testów jest trywialna:

Należy zaznaczyć, że w numeryce testy jednostkowe potrafią zaoszczędzić bardzo dużo czasu na polowaniach na bugi
poprzez automatyzację uruchamiania kolejnych partii kodu. Dobrze napisane testy są praktycznie koniecznością w dzisiejszych
czasach. % trochę soapbox?
% przykład kodu
% powinienem mieć coś w stylu make test czy setup.py test

* Numba
Innym podejściem do optymalizacji kodu napisanego w Pythonie jest kompilacja Just-In-Time, polegająca na % TODO: JIT


\section{Część weryfikacyjna} % 30-40% - opis wyników, analiza, weryfikacja i porównanie do danych literaturowych
\subsection{Przypadki testowe - porównanie z LPIC++}
\subsection{Benchmarki - szybkość, zasobożerność} %fix
\subsection{Problemy napotkane w trakcie pisania kodu}
\section{Zakończenie} % 3-5 stron
\section{Bibliografia} % 15-25 pozycji
1. Birdsall, Langdon
2. LPIC++
3. Buneman, Villasenor
4. Metody numeryczne


