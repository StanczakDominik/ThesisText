\section[Wstęp]{Wstęp} %2-3 strony wprowadzenie w temat, motywacja, teza (cel)
Algorytmy Particle-in-Cell ("cząstka w komórce") to jedne z najbardziej zbliżonych do fundamentalnej fizyki
metod symulacji materii w stanie plazmy. Zastosowany w nich lagranżowski opis cząsteczek pozwala na dokładne
odwzorowanie dynamiki ruchu elektronów i jonów. Jednocześnie, ewolucja pola elektromagnetycznego na Eulerowskiej
siatce dokonywana zamiast bezpośredniego obliczania oddziaływań międzycząsteczkowych pozwala na znaczące
przyspieszenie etapu obliczenia oddziaływań międzycząsteczkowych. W większości symulacji cząsteczkowych właśnie
ten etap jest najbardziej krytyczny dla wydajności progamu.

W ostatnich czasach symulacje Particle-in-Cell zostały wykorzystane m.in. do
\item symulacji przewidywanej turbulencji plazmy w reaktorze termojądrowym ITER %TODO: źródło,
\item modelowania rekonekcji linii magnetycznych w polu gwiazdy %TODO: źródło
\item projektowania silników jonowych (Halla) %TODO: jak wyżej
\item badania interakcji laserów z plazmą w kontekście tworzenia niewielkich,
wysokowydajnych akceleratorów cząstek %TODO

Należy zauważyć, że w świetle rosnącej dostępności silnie równoległej mocy obliczeniowej w postaci kart graficznych %TODO
możliwości algorytmów Particle-in-Cell będą rosły współmiernie, co może pozwolić na rozszerzenie ich zastosowań.
Inżynieria oprogramowania zorientowanego na wykorzystanie możliwości kart graficznych jest jednak utrudniona poprzez
niskopoziomowość %TODO: to sformułowanie zabiło JFK i chciałbym inne
istniejących technologii (CUDA, OpenCL) %TODO: źródło
co utrudnia pisanie złożonych programów, zwłaszcza przez osoby zajmujące się głównie pracą badawczą
niż wyłącznie programowaniem. %TODO: przeformułować

Niniejsza praca ma na celu utworzenie kodu symulacyjnego wykorzystującego metodę Particle-in-Cell w języku
wysokopoziomowym i %wyciśnięcie z niego tylu flopsów ile się da!
Ma to dwojaki sens:
\begin{enumerate}
    \item zweryfikowanie możliwości leżących w obecnych językach wysokopoziomowych bez wykorzystywania kart graficznych
    \item położenie fundamentów pod
\end{enumerate}
\section[Część analityczno-teoretyczna]{Część analityczno-teoretyczna} % 30% pracy - opis problematyki podjętego tematu w zakresie wykorzystanym w pracy i analizie

\subsection{Fizyka plazmy}

Plazma, powszechnie nazywana czwartym stanem materii, to zbiór zjonizowanych %TODO: formalna definicja plazmy
cząstek oraz elektronów. Plazmy występują w całym wszechświecie, od materii międzygwiezdnej po błyskawice.
Ich istnienie uwarunkowane jest obecnością wysokich energii, wystarczających do zjonizowania atomów gazu.

Fizyka plazmy jest stosunkowo młodą nauką, której rozwój nastąpił dopiero w ostatnim stuleciu, zaczynając od badań Alfvena. %TODO reference
Globalny wzrost zainteresowania fizyką plazmy rozpoczął się w latach '50 ubiegłego wieku, %TODO - zweryfikować
gdy uświadomiono sobie, że można zastosować ją do przeprowadzania kontrolowanych reakcji syntezy jądrowej, % TODO: reference: fusion in europe history of fusion
które mogą mieć zastosowania w energetyce jako następny etap rozwoju po reakcjach rozpadu wykorzystywanych
w "klasycznych" elektrowniach jądrowych.

Poza tym plazmy mają szerokie zastosowanie w przemyśle metalurgicznym, elektronicznym, kosmicznym itp. %TODO: to potrzebuje źródła

\subsection{Modelowanie i symulacja plazmy}

Zjawiska z zakresu fizyki plazmy są jednymi z bardziej złożonych problemów modelowanie komputerowej.
Głównym, koncepcyjnie, powodem uniemożliwiającym zastosowanie prostych metod symulacji
znanych z newtonowskiej dynamiki molekularnej jest mnogość oddziaływań - każda cząstka oddziałowuje
z każdą inną nawzajem poprzez niepomijalne na dużych odległościach oddziaływania kulombowskie $\approx r^{-2}$.

Z powodu dużej liczby cząstek w układach plazmowych, jedynymi praktycznymi podejściami są opisy statystyczne,
opierające się na modelach kinetycznych. Wielkością opisującą plazmę jest tu funkcja dystrybucji zdefiniowana jako 


\begin{equation}
    \int \int f(\vec{x}, \vec{v}, t) d\vec{x} d\vec{v} = 1 % normalizacja?
\end{equation}

opisująca gęstość prawdopodobieństwa rozkładu plazmy w N-sześciowymiarowej przestrzeni fazowej (po trzy wymiary na położenia
oraz prędkości, powielone dla każdej z N cząstek).

% TODO: dodać reference na opis statystyczny 

Podstawowym równaniem statystycznym opisującym plazmę jest równanie Vlasova % TODO: może zacząć od Klimontowicza, jest wyprowadzalne z niego

\begin{equation}
    \frac{ d} {dt} f_{\alpha} (\vec{x}, \vec{v}, t) - \nabla f - \nabla_\vec{v} (\vec{v} \times \vec{B} + \vec{E})= f_{coll}
% TODO: wzór na równanie Vlasova
\end{equation}

W praktyce jest ono również nierozwiązywalne. Jednym z powodów jest koniecznośc uzyskania dobrej rozdzielczości prędkości
przy jednoczesnym zachowaniu zakresów obejmujących prędkości relatywistyczne. % TODO: runaway electrons

W modelowaniu komputerowym plazmy stosuje się dwa główne podejścia:
\begin{enumerate}
\item modele płynowe oparte na ciągłym opisie plazmy poprzez uśrednienie po dystrybucji
wielkości termodynamicznych, co daje modele takie jak magnetohydrodynamikę %TODO: reformulate
\item modele dyskretne oparte na samplowaniu dystrybucji plazmy przy użyciu dyskretnych cząstek
        (matematycznie jest to równanie Klimontowicza przybliżające równanie Vlasova) %TODO: read about this
\end{enumerate}

Prawdopodobnie najpopoularniejszym modelem z tej drugiej kategorii są modele Particle-in-cell.

\subsection{Modele Particle-in-cell}

Idea modelu particle-in-cell jest wyjątkowo prosta i opiera się na idei przyspieszenia najbardziej złożonego obliczeniowo kroku
symulacji dynamiki molekularnej, czyli obliczania sił międzycząsteczkowych. Cząstki poruszają się w ciągłej, Lagrange'owskiej przestrzeni.
Ich ruch wykorzystywany jest do zebrania informacji dotyczącej gęstości ładunku i prądu na dyskretną, Eulerowską siatkę. Na siatce rozwiązane
są (jako równania różniczkowe cząstkowe) równania Maxwella, dzięki którym otrzymuje się pola elektryczne i magnetyczne, które z powrotem są przekazane
do położeń cząstek. Obliczeniowo, uwzględniając koszty odpowiednich interpolacji, pozwala to zredukować złożoność kroku obliczenia sił międzycząsteczkowych
do $n \log{n}$ z $n^2$ % TODO: wyrazić złożoność PIC przez rozmiar siatki

Algorytm particle-in-cell składa się z czterech elementów % GRAFIKA: cykliczny schemacik
\subsubsection{GATHER}
    Depozycja ładunku oraz prądu z położeń cząstek do lokacji na dyskretnej siatce poprzez interpolację,
    co pozwala na sprawne rozwiązanie na tej siatce
    równań Maxwella jako układu różnicowych równań cząstkowych zamiast obliczania skalujących się kwadratowo w liczbie cząstek
    oddziaływań kulombowskich między nimi.
    $1 = \sum_i S_i$<++> % TODO: dokończyć wzór
\subsubsection{SOLVE}
    Sprawne rozwiązanie równań Maxwella na dyskretnej, Eulerowskiej siatce;
    znalezienie pól elektrycznego i magnetycznego
    na podstawie gęstości ładunku i prądu na siatce.
    Istnieją dwie główne szkoły rozwiązywania tych równań: metody globalne i lokalne. Metody globalne wykorzystują
    zazwyczaj równania dywergencyjne, rozwiązywane iteracyjnie lub spektralnie,
    zaś lokalne - równania rotacyjne. Metody globalne nadają się do modeli elektrostatycznych, nierelatywistycznych.
    Metody lokalne pozwalają na ograniczenie szybkości propagacji zaburzeń do prędkości światła, co przybliża
    metodę numeryczną do fizyki zachodzącej w rzeczywistym układzie tego typu.
\subsubsection{SCATTER}
        Interpolacja pól z siatki do lokacji cząstek, co pozwala określić siły elektromagnetyczne działające na cząstki.
        Należy przy tym zauważyć, że jako że interpolacja sił wymaga jedynie lokalnej informacji co do pól
        elektromagnetycznych w okolicy cząstki, ta część algorytmu sprawia, że algorytmy Particle-in-cell doskonale
        nadają się do zrównoleglania (problem jest w przybliżeniu ``trywialnie paralelizowalny''). Z tego powodu algorytmy
        Particle-in-cell nadają się doskonale do wykorzystania rosnącej mocy kart graficznych i architektur GPGPU.
\subsubsection{PUSH}
    iteracja równań ruchu cząstek na podstawie ich prędkości (aktualizacja położeń)
    oraz działających na nie sił elektromagnetycznych (aktualizacja prędkości).

\subsubsection{Makrocząstki}
Należy zauważyć, że obecnie nie jest możliwe dokładne odwzorowanie dynamiki układów plazmowych w sensie interakcji
między poszczególnymi cząstkami ze względu na liczbę cząstek % rzędu liczby Avogadro ~10^23
W tym kontekście bardzo szczęśliwym jest fakt, że wszystkie istotne wielkości zależą nie od ładunku ani masy,
ale od stosunku $q/m$. W praktyce stosuje się więc \emph{makrocząstki}, obdarzone ładunkiem i masą będące wielokrotnościami
tych wielkości dla cząstek występujących w naturze (jak jony i elektrony, pozwalając jednocześnie zachować gęstości
cząstek i ładunku % oraz inne wielkości fizyczne)
zbliżone do rzeczywistych.

\subsection{Problem testowy}

Problemem testowym, jakiego używamy do przetestowania wydajności działania algorytmu jest
interakcja impulsu laserowego z tarczą składającą się ze zjonizowanego wodoru i elektronów.

Układ ten modelowany jest jako jednowymiarowy. Jest to tak zwany w literaturze model 1D-3D. O ile położenia cząstek
są jednowymiarowe ze względu na znaczną symetrię
cylindryczną układu, cząstki mają prędkości w pełnych trzech wymiarach. Jest to konieczne ze względu
na oddziaływania cząstek z polem elektromagnetycznym propagującym się wzdłuż osi układu.

\subsection{Python}
Python jest wysokopoziomowym, interpretowanym językiem programowania, którego atutami są szybkie prototypowanie,

Python znajduje zastosowania w analizie danych, uczeniu maszynowym (zwłaszcza w astronomii). W zakresie symulacji
w ostatnich czasach powstały kody skalujące się nawet w zakres superkomputerów, np. w mechanice płynów % TODO: PyFR

Atutem Pythona w wysokowydajnych obliczeniach jest łatwość wywoływania w nim zewnętrznych bibliotek napisanych
na przykład w C lub Fortranie, co pozwala na osiągnięcie podobnych rezultatów wydajnościowych jak dla kodów
napisanych w C.

\subsection{Optymalizacja kodu}

\subsubsection{Numpy}
Numpy to biblioteka umożliwiająca wykonywanie obliczeń macierzowych. Pod zewnętrzną powłoką zawiera odwołania do
wypróbowanych modułów LAPACK, BLAS %itd - dopisać przykłady pozostałych bibliotek algebraicznych oraz zweryfikować na czym
% w ogóle stoi numpy
napisanych w szybkich, niskopoziomowych językach C oraz FORTRAN. Jest to de facto standard większości obliczeń
numerycznych w Pythonie.
\subsubsection{Numba}
Numba to biblioteka służąca do kompilacji just-in-time kodu. % ogarnąć jak właściwie działa numba
W wielu przypadkach % odniesienie
pozwala na osiągnięcie kodem napisanym w czystym Pythonie wydajności marginalnie niższej bądź nawet równej do analogicznego
programu w C. % czy były takie testy z fortranem
Jednocześnie 
\subsubsection{HDF5}
HDF5 jest wysokowydajnym programem plikow służącym przechowywaniu danych liczbowych w drzewiastej strukturze danych.
W Pythonie implementuje go biblioteka h5py.
Używa się go na przykład w % lista miejsc gdzie używają hdf5
W bieżącej pracy  wykorzystuje się go do przechowywania danych dot. symulacji, pozwalających na postprocessinge<F9><F8>

\section[Implementacja]{Implementacja}% 20-30% - opis przyjętych rozwiązań i uzasadnienie ich wyboru
\subsection{Opis i treść kodu}
Cały kod programu w celu reprodukowalności wyników tworzony był i jest dostępny na platformie Github %link

\subsection{Struktura i hierarchia kodu}

Program ma obiektową strukturę zewnątrzą, którą w celu łatwości zrozumienia jego działania nakrywa wewnętrzną warstwę
składającą się głównie z n-wymiarowych tablic \emph{NumPy} oraz zwektoryzowanych operacji na nich.

Kod składa się z kilku prostych koncepcyjnie elementów:

\subsubsection{Species}
Klasa reprezentująca pewną grupę makrocząstek (np. odpowiadające elektronom w symulacji).

Zawiera skalary:
\begin{itemize}
\item $N$ - liczba makrocząstek
\item $q$ - ładunek makrocząstki
\item $m$ - masa makrocząstki
\item $c$ - prędkość światła
\end{itemize}

Zawiera tablice rozmiaru $N$:
\begin{itemize}
\item jednowymiarowych położeń makrocząstek $x^n$, zapisywanych w iteracjach $n, n+1, n+2$...
\item trójwymiarowych prędkości makrocząstek $\vec{v}^{n+\frac{1}{2}}$, zapisywanych w iteracjach $n+\frac{1}{2}, n+{3}{2}, n+{5}{2}$...
\item stanu makrocząstek (flagi boolowskie oznaczające cząstki aktywne bądź usunięte z obszaru symulacji)
\end{itemize}

Poza tym, zawiera też informacje dotyczące zbierania danych dot. cząstek:
\begin{itemize}
    \item stringowy identyfikator grupy cząstek, dla potrzeb legend wykresów
    \item $N_T$ - liczbę iteracji czasowych w symulacji
    \item odpowiadające poprzednio wymienionym tablice rozmiaru $N_T * N$
\end{itemize}

%TODO: jeżeli liczba makrocząstek lub iteracji przekracza pewną stałą, dane zapisywane są jedynie co tyle
% iteracji, aby zebrać właśnie tyle snapshotów cząstek. % REWRITE

\subsubsection{Grid}
Klasa reprezentująca dyskretną siatkę, na której dokonywane są obliczenia dot. pól elektromagnetycznych.

Klasa zawiera:
\begin{itemize}
    \item $x_i$ - tablicę położeń lewych krawędzi komórek siatki
    \item $N_G$ - liczbę komórek siatki
    \item $\Delta x$ - krok przestrzenny siatki - $N_G * \Delta x$ daje długość obszaru symulacji
    \item $\rho_i$ - tablicę gęstości ładunku na siatce
    \item $\vec{j}_{i,j}$ - tablicę gęstości prądu na siatce
    \item $E_{i,j}$ - tablicę pola elektrycznego na siatce
    \item $B_{i,j}$ - tablicę pola magnetycznego na siatce
    \item $n_{\text{species}}$ - liczbę rodzajów cząstek w symulacji, na potrzeby wykresów
    \item $c$, $\epsilon_0$ - stałe fizyczne - prędkość światła oraz przepuszczalność elektryczną próżni % REWRITE: nazwa stałej
\end{itemize}



\subsubsection{Simulation}
Klasa zbierająca w całość Grid oraz dowolną liczbę Species zawartych w symulacji, jak również
pozwalająca w prosty sposób na wykonywanie iteracji algorytmu i analizy danych. Jest tworzona tak przy
uruchamianiu symulacji, jak i przy wczytywaniu danych z plików .hdf5.

\begin{itemize}
\item $\Delta t$ - krok czasowy
\item $N_T$ - liczba iteracji w symulacji
\item \emph{grid} - obiekt siatki
\item \emph{list\_species} - lista grup makrocząstek w symulacji
\end{itemize}

\subsubsection{Pliki pomocnicze}
Poza powyższymi program jest podzielony na pliki:
\begin{itemize}
\item algorithms\_grid - zawiera algorytmy dot. rozwiązywania równań Maxwella na dyskretnej siatce
\item algorithms\_interpolation - zawiera algorytmy dot. interpolacji z cząstek na siatkę i odwrotnie
\item algorithms\_pusher - zawiera algorytmy integrujące numerycznie równania ruchu cząstek
\item animation - tworzy animacje dla celów analizy danych
\item static\_plots - tworzy statyczne wykresy dla celów analizy danych
\item Plotting - zawiera ustawienia dot. analizy danych % czy to można przenieść do simulation czy gdzieś?
\end{itemize}

Configi testowe są zawarte w plikach run\_*: % przeformułować
\begin{itemize}
\item run\_coldplasma
\item run\_twostream
\item run\_wave
\item run\_beam
\end{itemize}

Testy jednostkowe są zawarte w katalogu tests:

\subsection{Wybrane algorytmy}

\subsubsection{Leapfrog oraz Borys} % REWRITE
Należy zauważyć, że w inicjalizacyjnej iteracji algorytmu pomija się przesunięcie cząstek w przestrzeni, aktualizując jedynie
prędkości. Krok czasowy jest wtedy ustawiany na minus połowę swojej zwykłej wartości, co pozwala na obliczenia
z wykorzystaniem prędkości znanej w połowie kroku czasowego między kolejnymi iteracjami czasowymi. Jest to tzw. algorytm
leapfrog % reference
stosowany tam, gdzie potrzebna jest długofalowa stałość energii symulacji. Wynika to z symplektyczności % READ
tego rodzaju integratorów równań ruchu (w przeciwieństwie do, na przykład, standardowej metody Runge-Kutta 4, która
mimo swej większej dokładności nie zachowuje energii cząstek.

W przypadku ruchu w polu magnetycznym nie wystarczy, niestety, użyć zwykłego algorytmu leapfrog. % READ
Używa się tutaj specjanej adaptacji tego algorytmu na potrzeby ruchu w zmiennym polu elektromagnetycznym,
tzw pushera % REWRITE
Borysa % REFERENCE
który rozbija pole elektryczne na dwa impulsy, między którymi następują dwie % REWRITE
rotacje polem magnetycznym. Algorytm jest w ten sposób symplektyczny % REWRITE
i długofalowo zachowuje energię cząstek.

W tym przypadku stosuje się relatywistyczny algorytm Borysa, w którym jedyną faktyczną poprawką względem
nierelatywistycznego jest operowanie na pędach oraz sprowadzanie pędów do prędkości jako $\vec{v} = \vec{p} / \gamma$ %REWRITE

\subsubsection{Depozycja gęstości ładunku i prądu}
\subsubsection{Interpolacja pól elektrycznego i magnetycznego}
\subsubsection{Field solver} %TODO: przerobić

Ewolucja pola elektromagnetycznego opisana jest poprzez równania Maxwella. Jak pokazują Buneman i Ville % nazwisko
numerycznie można zastosować dwa główne podejścia: % zredagować
1. wykorzystać równania na dywergencję pola (prawa Gaussa) do rozwiązania pola na całej siatce. Niestety, jest to
algorytm inherentnie globalny, w którym informacja o warunkach brzegowych jest konieczna w każdym oczku siatki
% alternatywa na słowo "oczko"?
2. wykorzystać równania na rotację pola (prawa Ampera i Faradaya), opisujące ewolucję czasową pól. Jak łatwo pokazać (Buneman),
dywergencja pola elektrycznego oraz magnetycznego nie zmienia się w czasie pod wpływem tak opisanej ewolucji czasowej:

Co za tym idzie, jeżeli rozpoczniemy symulację od znalezienia pola na podstawie warunków brzegowych i początkowych (gęstości
ładunku), możemy już dalej iterować pole na podstawie równań rotacji. Ma to dwie znaczące zalety:
* algorytm ewolucji pola staje się trywialny, zwłaszcza w 1D - ogranicza się do elementarnego dodawania i mnożenia %poprawić
* algorytm ewolucji pola staje się lokalny (do znalezienia wartości pola w danym oczku w kolejnej iteracji wykorzystujemy
jedynie informacje zawarte w tym właśnie oczku i potencjalnie jego sąsiadach % jak to faktycznie wygląda z tym algo?
co zapobiega problemowi informacji przebiegającej w symulacji szybciej niż światło oraz zapewnia stabilność na podstawie
warunku Couranta.

% TODO: gładsze przejście tutaj
W 1D można dokonać dekompozycji składowych poprzecznych pola elektromagnetycznego (tutaj oznaczanych $y$, $z$) na
propagujące się w przód ($+$) i w tył ($-$) obszaru symulacji. Składowe $E_y$, $B_z$ są zebrane w % słowo

Wychodzimy z rotacyjnych równań Maxwella:

\begin{equation}
    \nabla \times \vec{E} = -\frac{\partial \vec{B}}{\partial t}
\end{equation}

\begin{equation}
    \nabla \times \vec{B} = \mu_0 (\vec{j} + \epsilon_0 \frac{\partial \vec{E}}{\partial t})
\end{equation}

% TODO: skończyć wyprowadzenie

\begin{equation}
    F^{+} = E_y + c B_z
\end{equation}
\begin{equation}
    F^{-} = E_y - c B_z
\end{equation}
Analogicznie, dla składowych $E_z$, $B_y$:

% TODO: zweryfikować znaki i czy c nie jest w mianowniku
\begin{equation}
    G^{+} = E_z - c B_y
\end{equation}
\begin{equation}
    G^{-} = E_z + c B_y
\end{equation}
Wyrazem ``źródłowym'' dla F, G jest prąd poprzeczny. Po dyskretyzacji równania, wyrażenie na ewolucję pól F, G między
iteracjami przybiera postać:

\begin{equation}
    F^{+}^{n+1}_{i+1} = F^{+}<++>_{n} + j%sprawdzić
\end{equation}

Z tego powodu bardzo istotnym dla dokładnośći i stabilności algorytmu staje się sposób depozycji ładunku - należy pilnować,
aby był robiony w sposób który spełnia zachowanie ładunku.

\subsection{Implementacja podstawowych algorytmów numerycznych stosowanych w symulacji}

\subsection{Wykorzystane techniki i technologie}
\begin{itemize}
    \item obliczenia wektorowe
    \item pytest; Test-driven development
    \item format plików danych hdf5
    \item wykresy: matplotlib
    \item scipy
    \item numba
    \item numpy
\end{itemize}

Przy pracy nad kodem użyto frameworku testowego pytest %link w stopce
Obsługa testów jest trywialna:

Należy zaznaczyć, że w numeryce testy jednostkowe potrafią zaoszczędzić bardzo dużo czasu na polowaniach na bugi
poprzez automatyzację uruchamiania kolejnych partii kodu. Dobrze napisane testy są praktycznie koniecznością w dzisiejszych
czasach. % trochę soapbox?
% przykład kodu
% powinienem mieć coś w stylu make test czy setup.py test

\subsubsection{Numba}

Innym podejściem do optymalizacji kodu napisanego w Pythonie jest kompilacja Just-In-Time, polegająca na % TODO: JIT

\subsection{Depozycja ładunku i prądu}

Depozycja ładunku i prądu polega na obliczeniu na podstawie położenia i prędkości każdej cząstki jej wkładu do
gęstości prądu i ładunku na siatce, oraz zwiększeniu bieżących wartości o ten wkład.

W symulacji stosowana jest liniowa interpolacja - cząstki mają ``szerokość'' jednej komórki siatki, zaś ich wkład do $i$
komórki jest proporcjonalny do przekrycia między powierzchnią cząstki a powierzchnią siatki.

Stosowany algorytm jest rekurencyjny i uwzględnia zachowanie ładunku/prądu %TODO: rewrite
%TODO: villasenor/buneman
co pozwala na uniknięcie stosowania poprawek % div B, div E
%(co łatwo pokazać, div E\ldots)
Dzięki temu algorytm obliczania zmian w polu elektromagnetycznym znacznie się upraszcza.


\begin{equation}
    \varepsilon_3 = \frac{x_n - (x_i + \frac{dx}{2})}{x_{n+1} - x_n}
\end{equation}
\begin{equation}
    \rho_i^{n+1} = \frac{q}{\Delta x} (x_i + \frac{\Delta x}{2} - x^{n+1})
\end{equation}
\begin{equation}
    \rho_{i-1}^{n+1} = \frac{q}{\Delta x} (x^{n+1} - (x_i - \frac{\Delta x}{2}))
\end{equation}
\begin{equation}
    j_{x,i+1}^{n+1/2} = q (\frac{1}{2} + \frac{x^n - x_{i+1}}{\Delta x})
\end{equation}
\begin{equation}
    j_{x,i}^{n+1/2} = q (\frac{1}{2} - \frac{x^{n+1} - x_i}{\Delta x})
\end{equation}
\begin{equation}
    <\rho_{i+1}> = \frac{q \varepsilon}{2} (\frac{1}{2} - \frac{x_{i+1} - x^n}{\Delta x})
\end{equation}
\begin{equation}
    <\rho_{i-1}> = q \frac{1- \varepsilon}{2} (\frac{1}{2} - \frac{x^n - x_i}{\Delta x})
    % todo
\end{equation}
\begin{equation}
    <\rho_{i}> = q \Bigg(\frac{\varepsilon}{2} (\frac{3}{2} + \frac{x^n-x_i}{\Delta x}) +\
    \frac{1-\varepsilon}{2} (\frac{3}{2} - \frac{x^{n+1} - x_{i+1}}{\Delta x})\Bigg)
\end{equation}

\section[Weryfikacja]{Część weryfikacyjna} % 30-40% - opis wyników, analiza, weryfikacja i porównanie do danych literaturowych
Niniejsza analiza przeprowadzona została na ``finalnej'' w chwili pisania niniejszej pracy wersji programu.
W repozytorium gita na Githubie jest to commit ``placeholder'' % TODO: uzupełnić commita
identyfikowany również jako wersja 1.0.

\subsection{Przypadki testowe}

Kod przetestowano w dwojaki sposób. Pierwszym z nich są testy jednostkowe.
Poszczególne algorytmy podlegały testom przy użyciu ogólnodostępnego pakietu pytest % TODO: pytest reference.

Testy polegały na przeprowadzeniu fragmentu symulacji - w przypadku testów algorytmów było to na przykład wygenerowanie
pojedynczej cząstki o jednostkowej prędkości oraz zdepozytowanie jej gęstości prądu na siatkę, co pozwala porównać
otrzymany wynik z przewidywanym analitycznie dla danego rozmiaru siatki i położenia cząstki. Automatyczne testy
jednostkowe uruchamiane po każdej wymiernej zmianie kodu pozwalają kontrolować działanie programu znacznie ułatwiają
zapobieganie błędom.

\begin{enumerate}
    \item Gather
    \begin{enumerate}
        % TODO: itemii?
        \item Depozycja prądu z pojedynczej cząstki na niewielką siatkę
        \item Depozycja prądu z dwóch pojedynczych cząstek na niewielką siatkę
              i porównanie z sumą prądów dla obu pojedynczyczh cząstek
        \item Depozycja prądu z dużej ilości równomiernie rozłożonych cząstek
    \end{enumerate}

    \itemi Solve
    \begin{enumerate}
        \item % TODO
    \end{enumerate}

    \itemi Scatter
    \begin{enumerate}
        \item % TODO
    \end{enumerate}

    \itemi Push
    \begin{enumerate}
        \item Ruch w jednorodnym polu elektrycznym wzdłuż osi układu
        \item Ruch w jednorodnym polu elektrycznym z polem magnetycznym % TODO: zrobić to
    \end{enumerate}
\end{enumerate}

Aby zweryfikować działanie kodu, zastosowano kod do symulacji kilku znanych problemów w fizyce plazmy:
\subsubsection{oscylacje zimnej plazmy}
\subsubsection{niestabilność dwóch strumieni}

\subsection{Symulacja oddziaływania lasera z tarczą wodorową}
\subsection{Benchmarki - szybkość, zasobożerność} %fix
\subsection{Problemy napotkane w trakcie pisania kodu}

\section[Zakończenie]{Zakończenie} % 3-5 stron
Utworzono kod symulacyjny implementacyjny algorytm particle-in-cell w Pythonie przy użyciu wszystkich dostępnych
możliwości, jakie daje ekosystem open-source. Kod zoptymalizowano przy użyciu % TODO: zoptymalizować.
Otrzymane wyniki benchmarków pozwalają sądzić, że % jest moc

