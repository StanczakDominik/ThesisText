\section[Implementacja]{Implementacja}% 20-30% - opis przyjętych rozwiązań i uzasadnienie ich wyboru
    \subsection{Całkowanie równań ruchu}
    Każda symulacja cząstek wymaga zastosowania integratora równań ruchu.
    Tradycyjnym przykładem takiego integratora jest integrator Rungego-Kutty
    czwartego rzędu, znajdujący zastosowanie w wielorakich symulacjach.
    \todo[inline]{reference}

    Niestety, w bieżącym kodzie nie można go zastosować ze względu na jego
    niesymplektyczność: mimo ogromnej dokładności jest on niestabilny pod
    względem energii cząstek. \todo[inline]{reference} W symulacjach typu
    Particle-in-cell konieczne jest zastosowanie innych algorytmów. Dobrym
    algorytmem symplektycznym jest na przykład powszechnie znany
    \emph{leapfrog}, polegający na przesunięciu prędkości o połowę iteracji
    czasowej względem położeń.\todo[inline]{reference} Mimo tego, że energie
    cząstek w ruchu obliczonym tym integratorem nie są lokalnie stałe na
    krótkich skalach czasowych, to jednak zachowują energię na skali globalnej.

    \todo[inline]{IMAGE: chyba miałem to na coldplasma}

    W przypadku ruchu w polu magnetycznym nie wystarczy, niestety, użyć
    zwykłego algorytmu \emph{leapfrog}. \todo[inline]{READ} Używa się tutaj
    specjalnej adaptacji tego algorytmu na potrzeby ruchu w zmiennym polu
    elektromagnetycznym, tak zwanego integratora Borysa,
    \todo[inline]{REFERENCE} który rozbija pole elektryczne na dwa impulsy,
    między którymi następują dwie rotacje polem magnetycznym. Algorytm jest
    dzięki temu symplektyczny i długofalowo zachowuje energię cząstek.

    \begin{align}
        \vec{v}^- = \vec{v}^{n-1/2} + \frac{q dt}{2m} \vec{E}^n
        \vec{t} = \frac{q dt} {2 m} \vec{B}^n
        \vec{v'} = \vec{v}^- + \vec{v}^- \times \vec{t}
        \vec{s} = \vec{t} / {(1 + t^2)}
        \vec{v}^+ = \vec{v}^- + \vec{v'} \times \vec{s}
        \vec{v}^{n+1/2} = \vec{v}^+ + \frac{q dt}{2m} \vec{E}^n
        \vec{x}^{n+1} = \vec{x}^{n} + \vec{v}^{n+1/2} dt
        \label{eqn:boris-pusher}
    \end{align}

    W naszym przypadku dochodzi jeszcze jedno utrudnienie związane z
    relatywistycznymi prędkościami osiąganymi przez cząstki (zwłaszcza
    elektrony) w symulacji. Przed obliczeniem korekty prędkości konieczne jest
    przetransformowanie prędkości z układu ``laboratoryjnego'' $\vec{v}$ na
    prędkość w układzie poruszającym się z cząstką $\vec{u}$, czego dokonuje
    się poprzez prostą transformację:

    \begin{align}
        \vec{u} = \vec{v} \gamma
        \gamma = \sqrt{1+{(u/c)}^2} = 1/\sqrt{1-{(v/2)}^2}
        \label{eqn:gamma-transformation}
    \end{align}

    \subsection{Depozycja gęstości prądu}

    Kolejnym krokiem pętli obliczeniowej po rozwiązaniu równań ruchu na
    aktualizację prędkości, po której - przypomnijmy - dysponujemy położeniami
    cząstek $x^n$ w chwilach $n$ oraz ich prędkościami $v^{n+1/2}$ w chwilach
    $n+1/2$  \todo[inline]{CHECK} jest obliczenie prądów podłużnych i
    poprzecznych potrzebnych do obliczenia wartości pól elektromagnetycznych w
    kolejnej iteracji.

    W bieżącym programie gęstość ładunku jest tak naprawdę niepotrzebna w
    trakcie symulacji. Ewolucja pola następuje poprzez znajomość gęstości prądu.
    Jeżeli zaś pole elektromagnetyczne spełniało warunek \todo[inline]{prawa
    Gaussa} na początku, depozycja prądu w sposób zachowujący ładunek zapewni
    dalsze zachowanie tego warunku w koeljnych iteracjach.

    Wyjątek stanowi początek symulacji, w której pole faktycznie musi zostać
    obliczone od podstaw na podstawie gęstości ładunku. \code{PythonPIC} pozwala
    poradzić sobie z tym problemem. Pierwszą opcją jest ustawienie początkowych
    położeń ładunków na identyczne między cząstkami negatywnymi i dodatnimi, co
    pozwala na siłowe wyzerowanie gęstości ładunku i brak pola elektrycznego w
    rejonie symulacji.

    Drugą, bardziej ogólną metodą pozwalającą na niezerowy rozkład gęstości
    ładunku  jest zebranie gęstości ładunku z początkowych położeń cząstek i
    rozwiązanie równań na pola metodą globalną (na przykład spektralnie). Jest
    to jedyny moment, gdzie zebranie gęstości ładunku jest faktycznie konieczny.
    Mimo to, gęstość cząstek (proporcjonalna do gęstości ładunku jako $\rho =
    \sum_s q_s n_s$) jest wciąż zbierana w symulacji jako wygodna diagnostyka
    ewolucji przestrzennej plazmy w obszarze symulacji. Ze względu na prostotę
    algorytmu, nie zabiera ona dużo czasu obliczeniowego (do
    \todo[inline]{sprawdzić dokładnie ile, rzędu 4\%}\%) czasu trwania symulacji).

    \subsubsection{Depozycja ładunku}

     Depozycja ładunku odbywa się w prosty sposób. Dla każdego gatunku
    cząstek obliczana jest ich gęstość liczbowa (koncentracja). Najpierw
    obliczane jest względne położenie każdej cząstki w komórce, do której
    przynależy, poprzez
    \begin{equation}
    x' = (x/dx) - i_x
    \label{eqn:relative-position}
    \end{equation}
    Następnie gęstość cząstki jest rozkładana pomiędzy bieżącą komórkę a
    komórkę następną w stosunku $n_i = 1-x'$, $n_{i+1} = x'$. Cząstka będąca
    w połowie komórki depozytowałaby więc swój ładunek po równo między obie
    komórki.

    \todo[inline]{mam wrażenie że jako że tego nie wykorzystuję w symulacji to
    to może być nieco błędne, środki komórek Eulera wg depozycji ładunku są w
    połowie. Niemniej jednak, elektrostatyczne symulacje okresowe zdają się
    działać w ten sposób, nawet gdy liczę ewolucję pól poprzez prądy. To wymaga
    dalszej weryfikacji.}

    \todo[inline]{RYSUNEK depozycja ładunku}

    Po obliczeniu otrzymana tablica gęstości \emph{makrocząstek} cząstek na
    siatce jest mnożona przez parametr \code{scaling} cząstek, co pozwala na
    obliczenie gęstości rzeczywistych cząstek modelowanych przez makrocząstki.
    Tablica gęstości ładunku jest otrzymywana poprzez zsumowanie tablic gęstości
    wszystkich gatunków cząstek w układzie.

    % \begin{itemize}
    %     \item Każda makrocząstka ma własny (wspólny wewnątrz \code{Species})
    %         ładunek $q$ oraz parametr \code{scaling} (również)
    %         \todo[inline]{STYLE?}
    %         decydujący o tym, ile rzeczywistych cząstek reprezentuje.
    %         Sumaryczny ładunek makrocząstki wynosi więc \code{q*scaling}
    %     \item Każda makrocząstka ma szerokość jednej komórki siatki $\Delta x$.
    %         Cząstka zlokalizowana więc środkiem
    %         w połowie długości komórki będzie w niej całkowicie zawarata.
    %     \item W ten sposób możemy stwierdzić, \todo[inline]{CONTINUE}
    % \end{itemize}

    % Powszechnie stosowaną od zarania dziejów metod particle-in-cell
    % \todo[inline]{refka: Dawson} jest interpolacja liniowa, polegająca na
    % zdepozytowaniu w $i$-tej komórce siatki \todo[inline]{dokończyć}
    %
    % $1 = \sum_i S_i$ \todo[inline]{dokończyć wzór}
    %
    % \todo[inline]{rysunek}
    %
    % W naszym przypadku wymagamy również, żeby depozycja prądu była spójna z
    % depozycją ładunku, to znaczy zachowywała ładunek.

    \subsection{Interpolacja pól elektrycznego i magnetycznego}

    Interpolacja pól elektrycznego i magnetycznego odbywa się na bardzo podobnej
    zasadzie, co depozycja ładunku. Wartosci pól są liniowo skalowane do pozycji
    makrocząstek według ich względnych położeń (równanie
    \ref{eqn:relative-position}) wewnątrz komórek.

    \begin{equation}
        F = F_i * (1-x') + F_{i+1} * x'
        \label{eqn:field-interpolation}
    \end{equation}

    \subsection{Depozycja prądu}

    Depozycja prądu jest bardziej złożonym zagadnieniem niż depozycja ładunku.
    Prądy wymagają bowiem informacji o prędkości czastek w połówkowych
    iteracjach $v^{n+1/2}$, ale sama interpolacja do komórek siatki wymaga
    położeń w iteracji całkowitej $x^{n}$. Poza tym jest też kwestia, że zwykłe
    liniowe przeskalowanie ładunku i parametru \code{scaling} przez prędkość w
    danym kierunku nie jest wystarczające z tego powodu, że taki sposób
    depozycji nie spełnia warunku zachowania ładunku.

    \todo[inline]{jak sformalizować warunek zachowania ładunku}

    \todo[inline]{depozycja ładunku w mojej obecnej wersji nie jestem wcale
    przekonany że zachowuje ładunek}

    To zaś dyskwalifikuje prostą liniową interpolację jako metodę depozycji
    prądu, ponieważ chcemy rozwiązywać lokalne równania Ampere'a-Maxwella
    \todo[inline]{nazwisko} zamiast liczyć globalne równania Poissona i Gaussa.
    Jeżeli chcemy uniknąć obliczania poprawek korygujących dywergencję pól,
    musimy to okupić większą złożonością algorytmu depozycji prądu.

    Depozycja prądu jest rozbita na dwie części - prąd podłużny i prąd
    poprzeczny. Jest to spowodowane tym, że ruch w kierunkach $y$, $z$ nie
    powoduje w symulacji przesuwania cząstek, a w $x$ już tak. Obliczenie prądu
    w kierunkach poprzecznych jest więc jednoznaczne z obliczeniem skalowanego
    \emph{przekrycia} cząstek z komórkami, przez które przechodzą w trakcie
    ruchu.

    Jako że cząstki mają szerokość równą szerokości komórki $\Delta x$, ich
    prędkość jest ograniczona przez prędkość światła, zaś za krok czasowy
    przyjmujemy $\Delta t = \Delta x/c$, można łatwo zauważyć, że maksymalna
    odległość, jaką cząstka mogłaby przebyć w jednej iteracji, to $\Delta x$.
    Jeżeli cząstka wystartowałaby środkiem w lewej krawędzi komórki (swoją
    własną lewą krawędzią sięgając środka poprzedniej komórki, a prawą połowy
    obecnej komórki), to w czasie ruchu przejechałaby \todo[inline]{spelling}
    przez łącznie trzy komórki. \todo[inline]{zweryfikować z algorytmem}

    Algorytm rozbija ruch cząstek w bieżącej iteracji na etapy. W każdym z
    etapów cząstka obejmuje swoim zasięgiem inne komórki. Pętla obliczeniowa
    akumuluje prąd dla cząstek w następujący sposób, zaczynając z przydzielonym
    czasem w bieżącej iteracji $t = \Delta t$.

    \subsubsection{Depozycja podłużna}
    \begin{enumerate}
        \item obliczany jest czas potrzebny cząstce na dotarcie do kolejnej
        granicy obszaru
        \begin{equation}
            t_l = (x - x_g)/v
        \end{equation}
        Granica obszaru jest definiowana jako najbliższa połowa komórki Eulera w kierunku
        ruchu cząstki.
        \item
        \begin{itemize}
            \item jeżeli cząstka ma wystarczająco czasu $t$ (spełnia warunek $t > t_l$) aby
            dotrzeć do kolejnej granicy obszaru, jej prąd zostaje zdepozytowany przez czas $t_l$,
            \item W przeciwnym razie prąd jest depozytowany przez czas $t$ i ruch cząstki kończy się.
        \end{itemize}
        Wkład cząstki do depozytowanego prądu wynosi
        \begin{equation}
            j_x = q n v_x t/\Delta t
        \end{equation}
        gdzie $q$ to ładunek cząstki, a $n$ to parametr \code{scaling} oznaczający liczbę
        rzeczywistych cząstek w makrocząstce.

        \item Jeżeli ruch cząstki się nie skończył, zostaje ona (w pętli
        wewnętrznej, niezależnie od jej faktycznego ruchu w symulacji)
        \todo[inline]{właściwie możnaby zoptymalizować w ten sposób ruch cząstek,
        wyciąć $x += v_x \Delta t$} przesunięta za granicę obszaru o $\varepsilon =
        10^{-10} \Delta x$. Dodanie $\varepsilon$ jest wykonywane w celu zwiększenia
        jednoznaczności porównywania liczb zmiennoprzecinkowych przy wybieraniu
        gałęzi algorytmu.

        Pętla obliczeniowa wykonuje kolejną iterację dla takiej cząstki, która tym razem
        ma przydzielony czas $t' = t - t_l$.

        \todo[inline]{Do której komórki trafia ładunek w każdej iteracji?}
    \end{enumerate}

    W każdej iteracji pętli obliczeniowej prąd ze wszystkich cząstek jest
    akumulowany do tablicy prądów. Tablica ma rozmiar \code{NG+2} \todo[inline]{verify}

    \subsubsection{Depozycja poprzeczna}
    Algorytm jest identyczny do depozycji podłużnej poza samym etapem depozycji
    prądu. Jako że symulacja jest jednowymiarowa i cząstki nie wykonują
    faktycznego ruchu w kierunkach $y$, $z$, przyjmujemy liniową iterpolację
    prądów w tych kierunkach jako iloczynów $j=qv$ ważonych przez przekrycie
    cząstki z komórkami oraz czas, jaki cząstka spędza w ruchu obejmując dane
    komórki.

    Przekrycie obliczamy jako
    \begin{equation}
        s =
    \end{equation}
    \todo[inline]{przekrycie}

    Aby uzyskać wartość średniego przekrycia cząstki z komórką w trakcie ruchu
    uśredniamy przekrycie na końcu ruchu z przekryciem na początku ruchu,
    \begin{equation}
        w = {(s(x^{n+1}) + s(x^n))}
    \end{equation}

    Ostatecznie wkład do komórki "obecnej" w ciągu jednej iteracji pętli obliczeniowej to \todo[inline]{zweryfikować}
    to $w * q n v_{y, z} t / \Delta t$.
    zaś do dalszej, przekrywanej komórki jest to  $(1-w) * q n v_{y, z} t / \Delta t$.
    \todo[inline]{jakoś poprawić stylistykę chyba}

    Tablica prądów poprzecznych, do których zostają depozytowane, ma rozmiar
    \code{NG+4, 2}. Jest to spowodowane większą liczbą komórek, przez które liniowa depozycja
    poprzez przekrycie jest w stanie "sięgnąć".

    \todo[inline]{zdecydowanie stylistyka}

    \todo[inline]{grafika}

    \subsection{Ewolucja czasowa pola elektromagnetycznego} \todo[inline]{przerobić}

    Ewolucja pola elektromagnetycznego opisana jest poprzez równania Maxwella.
    Jak pokazują Buneman i Villasenor, numerycznie można zastosować dwa główne
    podejścia: \todo[inline]{refka Buneman}

    \begin{enumerate}
        \item wykorzystać równania na dywergencję pola (prawa Gaussa) do
        rozwiązania pola na całej siatce. Niestety, jest to algorytm
        inherentnie globalny, w którym informacja o warunkach brzegowych
        jest konieczna w każdej komórce siatki.

        \item wykorzystać równania na rotację pola (prawa Ampera i Faradaya),
        opisujące ewolucję czasową pól. Jak łatwo pokazać (Buneman), dywergencja
        pola elektrycznego oraz magnetycznego nie zmienia się w czasie pod
        wpływem tak opisanej ewolucji czasowej:
    \end{enumerate}

    Co za tym idzie, jeżeli rozpoczniemy symulację od znalezienia pola na
    podstawie warunków brzegowych i początkowych (gęstości ładunku), możemy już
    dalej iterować pole na podstawie równań rotacji. Ma to dwie znaczące
    zalety:

    * algorytm ewolucji pola staje się trywialny obliczeniowo,
    zwłaszcza w 1D - ogranicza się bowiem do elementarnych operacji lokalnego
    dodawania i mnożenia.

    * algorytm ewolucji pola staje się lokalny (do
    znalezienia wartości pola w danym oczku w kolejnej iteracji wykorzystujemy
    jedynie informacje zawarte w tym właśnie oczku i potencjalnie jego
    sąsiadach \todo[inline]{jak to faktycznie wygląda z tym algo?} co zapobiega
    problemowi informacji przebiegającej w symulacji szybciej niż światło oraz
    zapewnia stabilność na podstawie
    warunku Couranta.

    \todo[inline]{gładsze przejście tutaj - wyprowadzenie field solvera}
    W 1D można dokonać dekompozycji składowych poprzecznych pola
    elektromagnetycznego (tutaj oznaczanych $y$, $z$) na propagujące się w
    przód ($+$) i w tył ($-$) obszaru symulacji. Składowe $E_y$, $B_z$ są
    zebrane poprzez zamianę zmiennych w dwie wielkości elektrodynamiczne $F^+$,
    $F^-$.

    Wychodzimy z rotacyjnych równań Maxwella:

    \begin{align}
        \nabla \times \vec{E} = -\frac{\partial \vec{B}}{\partial t}
        \nabla \times \vec{B} = \mu_0 (\vec{j} + \varepsilon_0 \frac{\partial \vec{E}}{\partial t})
        \label{eqn:Maxwell-rotation-derivation}
     \end{align}
    Jako że symulacja zakłada symetrię układu wzdłuż osi propagacji lasera $x$,
    możemy przyjąć $\frac{\partial}{\partial y} = \frac{\partial}{\partial z} =
    0 $.  Jednocześnie z prawa Gaussa dla pola magnetycznego wynika $B_x = 0$.
    Stąd równania dla pola elektrycznego podłużnego oraz pola
    elektromagnetycznego poprzecznego \todo[inline]{słowo - decouple}:

    \begin{equation}
        (\nabla \times \vec{B})_x = 0 = \mu_0 (j_x + \varepsilon_0 \frac{\partial E_x}{\partial t})
        \label{eqn:longitudinal-field-eq}
     \end{equation}

    Z kolei dla pola poprzecznego, sumując:
    \begin{equation}
        \nabla \times \vec{E} = -\frac{\partial \vec{B}}{\partial t}
        \nabla \times \vec{B} = \mu_0 (\vec{j} + \varepsilon_0 \frac{\partial \vec{E}}{\partial t})
        \nabla \times (\vec{E} + \vec{B}) = -\frac{\partial (\vec{B} + \mu_0 \varepsilon_0 \vec{E})}{\partial t} + \mu_0 \vec{j}
        c = 1/{\sqrt{\mu_0 \varepsilon_0}}
        \nabla \times (\vec{E} + \vec{B}) = -\frac{\partial (\vec{B} + \mu_0 \varepsilon_0 \vec{E})}{\partial t} + \mu_0 \vec{j}
        \label{eqn:perpendicular-field-eq}
    \end{equation}
    \todo[inline]{skończyć wyprowadzenie}
    Po dodaniu i odjęciu stronami:
    \begin{align}
        \nabla \times (\vec{E} + c \vec{B}) = -\frac{\partial \vec{B}}{\partial t} + c \mu_0 (\vec{j} +  \epsilon_0 \frac{\partial \vec{E}}{\partial t})
        \nabla \times (\vec{E} - c \vec{B}) = -\frac{\partial \vec{B}}{\partial t} - c \mu_0 (\vec{j} +  \epsilon_0 \frac{\partial \vec{E}}{\partial t})
        \label{eqn:Maxwell-rotation-derivation}
    \end{align}

    \begin{equation}
        F^{+} = E_y + c B_z
        F^{-} = E_y - c B_z
        \label{eqn:Birdsall-electromagnetic-quantities}
    \end{equation}
    Analogicznie, dla składowych $E_z$, $B_y$:

    \todo[inline]{zweryfikować znaki i czy c nie jest w mianowniku}
    \begin{equation}
        G^{+} = E_z + c B_y
        G^{-} = E_z - c B_y
        \label{eqn:Birdsall-electromagnetic-quantities-alternate-axes}
    \end{equation}
    Wyrazem ``źródłowym'' dla F, G jest prąd poprzeczny. Po dyskretyzacji
    równania, wyrażenie na ewolucję pól F, G między iteracjami przybiera
    postać:

    \begin{equation}
        {F^{+}}^{n+1}_{i+1} = F^{+}_{n} + j
    \end{equation}
\todo[inline]{sprawdzić}
    Z tego powodu bardzo istotnym dla dokładności i stabilności algorytmu staje
    się sposób depozycji ładunku - należy pilnować, aby był robiony w sposób
    który spełnia zachowanie ładunku. Inaczej koniecznym staje się aplikowanie
    tak zwanej poprawki Borysa, \todo[inline]{źródło - prezentacja}
    aby upewnić się, że warunek z równań Maxwella $\nabla \rho / \varepsilon_0
    = \nabla \cdot \vec{E}$ jest wciąż spełniony.

    Składowa podłużna pola jest obliczana poprzez wyrażenie

    \begin{equation}
    \frac{\partial E_x}{\partial t} = - \frac{j_x}{\varepsilon_0}
    \label{longitudinal-field-differential}
    \end{equation}

    czy raczej jej dyskretny odpowiednik

    \begin{equation}
        E_i^{n+1} = E_i^n - \frac{\Delta t}{\varepsilon_0} j_{x,i}^{n+1/2}
    \label{longitudinal-field-finite-differential}
    \end{equation}


    \subsection{Warunki początkowe dla cząstek}

    W celu dobrania warunków początkowych wykorzystuje się algorytm opisany w
    \todo[inline]{Birdsall Langdon} Jego działanie można łatwo zilustrować na
    przykładzie początkowej funkcji gęstości cząstek zadanej dowolną funkcją
    analityczną. \todo[inline]{czy analityczna nie jest słowem zarezerwowanych
    dla tych na szeregi}

    Używając funkcji dystrybucji w jednym wymiarze zależnej jedynie od
    położenia znormalizowanej do liczby cząstek $N$, można wykonać całkowanie
    kumulatywne po siatce gęstszej niż liczba cząstek na wybranym przedziale,
    po czym umieścić cząstki w miejscach, gdzie obliczona dystrybuanta funkcji
    przybiera kolejne większe całkowite wartości.

    \todo[inline]{rysunek: przykład z ipynb}

    Zaimplementowany algorytm jest w stanie przyjąć dowolną funkcję analityczną
    \todo[inline]{czy nie przesadzam?} i zrenormalizować ją tak, aby $\int_0^L
    f(x) dx = N$. W praktyce wykorzystuje się wartości marginalnie większe niż
    $N$, mianowicie $N+0.1$, co pozwala na uniknięcie problemów ze skończoną
    dokładnością obliczeń na liczbach zmiennoprzecinkowych.

    Aby uniknąć problemu w przypadku dwóch \code{Species} cząstek o identycznej
    liczbie makrocząstek i przeciwnym znaku które według powyższego algorytmu
    zostałyby rozłożone w identycznych miejscach z powodu niezależnego
    stosowania algorytmu dla każdej grupy cząstek, co prowadziłoby do
    neutralizacji ładunku na całej symulacji, na położenia cząstek nakłada się
    dodatkowy gaussowski szum o niewielkiej intensywności.

    Analogiczny algorytm znajduje zastosowanie w obliczaniu początkowych
    wartości prędkości dla cząstek.  Wykorzystuje się relatywistyczny rozkład
    Maxwella

    \begin{align}
        f(p) = \frac{N}{2 \pi} \frac{mc^2}{T} \frac{1}{1+T/mc^2} \exp \Big (\frac{-mc^2}{T}(\gamma -1) \Big)
        \gamma = \sqrt{1+p^2}
        \label{relativistic-maxwell-distribution}
    \end{align}

    Należy wspomnieć, że aby cząstki były prawidłowo ztermalizowane
    \todo[inline]{czy to jest słowo} należy zadbać o zdekorelowanie ich
    prędkości między sobą. Naiwne zastosowanie algorytmu na położenia prowadzi
    zaś do rozłożenia cząstek rosnąco numeracją w kierunku rosnącego położenia
    $x$.

    Rozwiązaniem tego problemu jest losowa zamiana prędkości między losowo
    wybranymi cząstkami.  \todo[inline]{dopisać jak będzie zrobione.}

    \subsection{Opis i treść kodu}
    Cały kod programu w celu reprodukowalności wyników tworzony był i jest
    dostępny na platformie Github \todo[inline]{link}

    \subsection{Struktura i hierarchia kodu}

    Program ma obiektową strukturę zewnętrzną, którą w celu łatwości
    zrozumienia jego działania nakrywa wewnętrzną warstwę składającą się
    głównie z n-wymiarowych tablic \code{numpy.ndarray} oraz zwektoryzowanych
    operacji na nich.

    Część symulacyjna kodu składa się z kilku prostych koncepcyjnie elementów:

    \subsubsection{Grid}
    Klasa reprezentująca dyskretną siatkę Eulera, na której dokonywane są
    obliczenia dotyczące pól elektromagnetycznych oraz gęstości ładunku i
    prądu.  Zawiera:
    \begin{itemize}
        \item $x_i$ - tablicę położeń lewych krawędzi komórek siatki
        \item $N_G$ - liczbę komórek siatki
        \item $T$ - sumaryczny czas trwania symulacji
        \item $\Delta x$ - krok przestrzenny siatki - $N_G * \Delta x$ daje
            długość obszaru symulacji
        \item $\rho_i$ - tablicę gęstości ładunku na siatce.
        \item $\vec{j}_{i,j}$ - tablicę gęstości prądu na siatce.
        \item $E_{i,j}$ - tablicę pola elektrycznego na siatce.
        \item $B_{i,j}$ - tablicę pola magnetycznego na siatce.
        \item $c$, $\varepsilon_0$ - stałe fizyczne - prędkość światła oraz
            przenikalność elektryczną próżni.
        \item $\Delta t$ - krok czasowy symulacji, obliczony jako $\Delta t =
            \Delta x / c$.
        \item $N_T$ - liczbę iteracji czasowych symulacji.
        \item \code{BC} - \emph{Boundary Condition}, funkcję czasu określającą
            wartość warunku brzegowego dotyczącego natężenia fali
            elektromagnetycznej (laserowej) wchodzącej do pola symulacji z
            lewej strony.
    \end{itemize}

    Istotne metody klasy \code{Grid}, o których należy wspomnieć, to:
    \begin{itemize}
         \item \code{apply\_bc} - aktualizuje krańcowe wartości tablic $E$, $B$
             w oparciu o podany warunek brzegowy.
         \item gather\_current \todo[inline]{finish these}
         \item gather\_charge
         \item solve
         \item field\_solve
         \item electric\_field\_function, magnetic
         \item save\_to\_h5py
    \end{itemize}

    \subsubsection{Species}
    Klasa reprezentująca pewną grupę makrocząstek o wspólnych cechach, takich
    jak ładunek bądź masa.  Przykładowo, w symulacji oddziaływania lasera z
    tarczą wodorową jedną grupą są protony, zaś drugą - elektrony.  Do
    zainicjalizowania wymaga instancji \code{Grid}, z której pobiera informacje
    takie jak stałe fizyczne $c$, $\varepsilon_0$, liczbę iteracji czasowych
    $N_T$ i czas trwania iteracji $\Delta t$.

    Zawiera skalary:
    \begin{itemize}
        \item $N$ - liczba makrocząstek
        \item $q$ - ładunek cząstki
        \item $m$ - masa cząstki
        \item \code{scaling} - liczba rzeczywistych cząstek, jakie reprezentuje
            sobą makrocząstka. Jej sumaryczny ładunek wynosi $q *
            $\code{scaling}, masa $m * $\code{scaling}.
        \item \code{N\_alive} - liczba cząstek obecnie aktywnych w symulacji.
            Zmniejsza się w miarę usuwania cząstek przez warunki brzegowe.
    \end{itemize}

    Poza skalarami zawiera tablice rozmiaru $N$:
    \begin{itemize}
        \item jednowymiarowych położeń makrocząstek $x^n$, zapisywanych w
            iteracjach $n, n+1, n+2$\ldots
        \item trójwymiarowych prędkości makrocząstek $\vec{v}^{n+\frac{1}{2}}$,
            zapisywanych w iteracjach $n+\frac{1}{2}, n+{3}{2}, n+{5}{2}$\ldots
        \item stanu makrocząstek (flagi boolowskie oznaczające cząstki aktywne
            bądź usunięte z obszaru symulacji)
    \end{itemize}

    Poza tym, zawiera też informacje dotyczące zbierania danych diagnostycznych
    dla cząstek, niepotrzebnych bezpośrednio w czasie symulacji:
    \begin{itemize}
        \item \code{name} - słowny identyfikator grupy cząstek, dla potrzeb legend wykresów
        \item $N_T$ - liczbę iteracji czasowych w symulacji
        \item $N_T^s$ - zmniejszoną liczbę iteracji, w których następuje pełne
            zapisanie położeń i prędkości cząstek.  Dane te są wykorzystywane
            do tworzenia diagramów fazowych cząstek.
        \item odpowiadające poprzednio wymienionym tablice rozmiaru $(N_T^s,
            N)$, $(N_T^s, N, 3)$.  \item jedną tablicę rozmiaru $(N_T, N_G)$
            dotyczącą zebranym podczas
            depozycji ładunku informacjom diagnostycznym o przestrzennej
            gęstości cząstek.
        \item trzy tablice rozmiaru $(N_T)$ dotyczącą średnich prędkości,
            średnich kwadratów prędkości i odchyleń standardowych prędkości.
    \end{itemize}

    Jeżeli liczba makrocząstek lub iteracji przekracza pewną stałą, dane zapisywane są jedynie dla co $n$-tej cząstki,
    gdzie $n$ jest najniższą liczbą całkowitą która pozwala na zmniejszenie tablic poniżej tej stałej.

    Warto wspomnieć o metodach klasy \code{Species}:
    \begin{itemize}
        \item push \todo[inline]{fill these}
    \end{itemize}

    \subsubsection{Simulation}
    Klasa zbierająca w całość Grid oraz dowolną liczbę Species zawartych w
    symulacji, jak również pozwalająca w prosty sposób na wykonywanie iteracji
    algorytmu i analizy danych. Jest tworzona tak przy uruchamianiu symulacji,
    jak i przy wczytywaniu danych z plików \code{.hdf5}.

    \begin{itemize}
        \item $\Delta t$ - krok czasowy
        \item $N_T$ - liczba iteracji w symulacji
        \item \code{Grid} - obiekt siatki
        \item \code{list\_species} - lista grup makrocząstek w symulacji
    \end{itemize}
    \todo[inline]{metody simulation}

    Przygotowanie warunków początkowych do danej symulacji polega na utworzeniu
    nowej klasy dziedziczącej po \code{Simulation}, która przygotowuje siatkę,
    cząstki i warunki brzegowe zgodnie z założeniami eksperymentu i wywołuje
    konstruktor \code{Simulation}.  Należy również przeciążyć metodę
    \code{grid\_species\_init}, która przygotowuje warunki początkowe. Domyślna
    wersja tej metody wykonuje pierwszą, początkową iterację równań ruchu,
    która pozwala na zachowanie symplektyczności integratora równań ruchu,
    \todo[inline]{stylistyka?} co pomaga zachować energię cząstek w symulacji.

    Aby uruchomić symulację, należy wywołać jedną z metod:
    \begin{itemize}
         \item \code{run} - podstawowy cykl obliczeń, używany do pomiarów
             wydajności programu
         \item \code{test\_run} - obliczenia oraz obróbka danych na potrzeby
             analizy, głównie stosowana w testach
         \item \code{lazy\_run} - \code{test\_run} z zapisem do pliku oraz
             wczytaniem z pliku \emph{.hdf5}, jeżeli początkowe warunki oraz
             wersja kodu zgadzają się. W przeciwnym razie symulacja zostaje
             uruchomiona na nowo.
    \end{itemize}

    \subsubsection{Pliki pomocnicze}
    Poza powyższymi program jest podzielony na pliki: \todo[inline]{aktualizacja}
    \begin{itemize}
        \item algorithms\_grid - zawiera algorytmy dotyczące rozwiązywania
            równań Maxwella na dyskretnej siatce
        \item algorithms\_interpolation - zawiera algorytmy interpolujące pola
            z cząstek na siatkę i odwrotnie
        \item algorithms\_pusher - zawiera algorytmy integrujące numerycznie
            równania ruchu cząstek
        \item animation - tworzy animacje dla celów analizy danych
        \item static\_plots - tworzy statyczne wykresy dla celów analizy danych
        \item plotting - zawiera ustawienia dotyczące analizy danych
            \todo[inline]{czy to można przenieść do simulation czy gdzieś?}
    \end{itemize}

    Przygotowane konfiguracje istniejących symulacji są zawarte w plikach
    \code{configs/run\_*}: \todo[inline]{przeformułować}
    \begin{itemize}
        \item run\_coldplasma
        \item run\_twostream
        \item run\_wave
        \item run\_beam
        \item run\_laser
    \end{itemize}

    Algorytmiczne testy jednostkowe są zawarte w katalogu \code{tests}.
