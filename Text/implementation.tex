\section{Opis i treść kodu} % 20-30% - opis przyjętych rozwiązań i uzasadnienie ich wyboru
Cały kod programu w celu reprodukowalności wyników tworzony był i jest dostępny na platformie Github %link

\subsection{Struktura i hierarchia kodu}

Program ma obiektową strukturę zewnątrzą, którą w celu łatwości zrozumienia jego działania nakrywa wewnętrzną warstwę
składającą się głównie z n-wymiarowych tablic \emph{NumPy} oraz zwektoryzowanych operacji na nich.

Kod składa się z kilku prostych koncepcyjnie elementów:

\subsubsection{Species}
Klasa reprezentująca pewną grupę makrocząstek (np. odpowiadające elektronom w symulacji).

Zawiera skalary:
\begin{itemize}
\item $N$ - liczba makrocząstek
\item $q$ - ładunek makrocząstki
\item $m$ - masa makrocząstki
\item $c$ - prędkość światła
\end{itemize}

Zawiera tablice rozmiaru $N$:
\begin{itemize}
\item jednowymiarowych położeń makrocząstek $x^n$, zapisywanych w iteracjach $n, n+1, n+2$...
\item trójwymiarowych prędkości makrocząstek $\vec{v}^{n+\frac{1}{2}}$, zapisywanych w iteracjach $n+\frac{1}{2}, n+{3}{2}, n+{5}{2}$...
\item stanu makrocząstek (flagi boolowskie oznaczające cząstki aktywne bądź usunięte z obszaru symulacji)
\end{itemize}

Poza tym, zawiera też informacje dotyczące zbierania danych dot. cząstek:
\begin{itemize}
    \item stringowy identyfikator grupy cząstek, dla potrzeb legend wykresów
    \item $N_T$ - liczbę iteracji czasowych w symulacji
    \item odpowiadające poprzednio wymienionym tablice rozmiaru $N_T * N$
\end{itemize}

%TODO: jeżeli liczba makrocząstek lub iteracji przekracza pewną stałą, dane zapisywane są jedynie co tyle
% iteracji, aby zebrać właśnie tyle snapshotów cząstek. % REWRITE

\subsubsection{Grid}
Klasa reprezentująca dyskretną siatkę, na której dokonywane są obliczenia dot. pól elektromagnetycznych.

Klasa zawiera:
\begin{itemize}
    \item $x_i$ - tablicę położeń lewych krawędzi komórek siatki
    \item $N_G$ - liczbę komórek siatki
    \item $\Delta x$ - krok przestrzenny siatki - $N_G * \Delta x$ daje długość obszaru symulacji
    \item $\rho_i$ - tablicę gęstości ładunku na siatce
    \item $\vec{j}_{i,j}$ - tablicę gęstości prądu na siatce
    \item $E_{i,j}$ - tablicę pola elektrycznego na siatce
    \item $B_{i,j}$ - tablicę pola magnetycznego na siatce
    \item $n_{\text{species}}$ - liczbę rodzajów cząstek w symulacji, na potrzeby wykresów
    \item $c$, $\epsilon_0$ - stałe fizyczne - prędkość światła oraz przepuszczalność elektryczną próżni % REWRITE: nazwa stałej
\end{itemize}



\subsubsection{Simulation}
Klasa zbierająca w całość Grid oraz dowolną liczbę Species zawartych w symulacji, jak również
pozwalająca w prosty sposób na wykonywanie iteracji algorytmu i analizy danych. Jest tworzona tak przy
uruchamianiu symulacji, jak i przy wczytywaniu danych z plików .hdf5.
 
\begin{itemize}
\item $\Delta t$ - krok czasowy
\item $\NT$ - liczba iteracji w symulacji
\item \emph{grid} - obiekt siatki
\item \emph{list\_species} - lista grup makrocząstek w symulacji
\end{itemize}

\subsubsection{Pliki pomocnicze}
Poza powyższymi program jest podzielony na pliki:
\begin{itemize}
\item algorithms\_grid - zawiera algorytmy dot. rozwiązywania równań Maxwella na dyskretnej siatce
\item algorithms\_interpolation - zawiera algorytmy dot. interpolacji z cząstek na siatkę i odwrotnie
\item algorithms\_pusher - zawiera algorytmy integrujące numerycznie równania ruchu cząstek
\item animation - tworzy animacje dla celów analizy danych
\item static\_plots - tworzy statyczne wykresy dla celów analizy danych
\item Plotting - zawiera ustawienia dot. analizy danych % czy to można przenieść do simulation czy gdzieś?
\end{itemize}

Configi testowe są zawarte w plikach run\_*: % przeformułować
\begin{itemize}
\item run\_coldplasma
\item run\_twostream
\item run\_wave
\item run\_beam
\end{itemize}

Testy jednostkowe są zawarte w katalogu tests:

\subsection{Wybrane algorytmy}

\subsubsection{Leapfrog oraz Borys} % REWRITE
Należy zauważyć, że w inicjalizacyjnej iteracji algorytmu pomija się przesunięcie cząstek w przestrzeni, aktualizując jedynie
prędkości. Krok czasowy jest wtedy ustawiany na minus połowę swojej zwykłej wartości, co pozwala na obliczenia
z wykorzystaniem prędkości znanej w połowie kroku czasowego między kolejnymi iteracjami czasowymi. Jest to tzw. algorytm
leapfrog % reference
stosowany tam, gdzie potrzebna jest długofalowa stałość energii symulacji. Wynika to z symplektyczności % READ
tego rodzaju integratorów równań ruchu (w przeciwieństwie do, na przykład, standardowej metody Runge-Kutta 4, która
mimo swej większej dokładności nie zachowuje energii cząstek.

W przypadku ruchu w polu magnetycznym nie wystarczy, niestety, użyć zwykłego algorytmu leapfrog. % READ
Używa się tutaj specjanej adaptacji tego algorytmu na potrzeby ruchu w zmiennym polu elektromagnetycznym,
tzw pushera % REWRITE
Borysa % REFERENCE
który rozbija pole elektryczne na dwa impulsy, między którymi następują dwie % REWRITE
rotacje polem magnetycznym. Algorytm jest w ten sposób symplektyczny % REWRITE
i długofalowo zachowuje energię cząstek.

W tym przypadku stosuje się relatywistyczny algorytm Borysa, w którym jedyną faktyczną poprawką względem
nierelatywistycznego jest operowanie na pędach oraz sprowadzanie pędów do prędkości jako $\vec{v} = \vec{p} / \gamma$ %REWRITE

\subsubsection{Depozycja gęstości ładunku i prądu}
\subsubsection{Interpolacja pól elektrycznego i magnetycznego}
\subsubsection{Field solver} %TODO: przerobić

Ewolucja pola elektromagnetycznego opisana jest poprzez równania Maxwella. Jak pokazują Buneman i Ville % nazwisko
numerycznie można zastosować dwa główne podejścia: % zredagować
1. wykorzystać równania na dywergencję pola (prawa Gaussa) do rozwiązania pola na całej siatce. Niestety, jest to
algorytm inherentnie globalny, w którym informacja o warunkach brzegowych jest konieczna w każdym oczku siatki
% alternatywa na słowo "oczko"?
2. wykorzystać równania na rotację pola (prawa Ampera i Faradaya), opisujące ewolucję czasową pól. Jak łatwo pokazać (Buneman),
dywergencja pola elektrycznego oraz magnetycznego nie zmienia się w czasie pod wpływem tak opisanej ewolucji czasowej:

Co za tym idzie, jeżeli rozpoczniemy symulację od znalezienia pola na podstawie warunków brzegowych i początkowych (gęstości
ładunku), możemy już dalej iterować pole na podstawie równań rotacji. Ma to dwie znaczące zalety:
* algorytm ewolucji pola staje się trywialny, zwłaszcza w 1D - ogranicza się do elementarnego dodawania i mnożenia %poprawić
* algorytm ewolucji pola staje się lokalny (do znalezienia wartości pola w danym oczku w kolejnej iteracji wykorzystujemy
jedynie informacje zawarte w tym właśnie oczku i potencjalnie jego sąsiadach % jak to faktycznie wygląda z tym algo?
co zapobiega problemowi informacji przebiegającej w symulacji szybciej niż światło oraz zapewnia stabilność na podstawie
warunku Couranta.

% TODO: gładsze przejście tutaj
W 1D można dokonać dekompozycji składowych poprzecznych pola elektromagnetycznego (tutaj oznaczanych $y$, $z$) na
propagujące się w przód ($+$) i w tył ($-$) obszaru symulacji. Składowe $E_y$, $B_z$ są zebrane w % słowo

Wychodzimy z rotacyjnych równań Maxwella:

\begin{equation}
    \nabla \times \vec{E} = -\frac{\partial \vec{B}}{\partial t}
\end{equation}

\begin{equation}
    \nabla \times \vec{B} = \mu_0 (\vec{j} + \epsilon_0 \frac{\partial \vec{E}}{\partial t})
\end{equation}

% TODO: skończyć wyprowadzenie

\begin{equation}
    F^{+} = E_y + c B_z
\end{equation}
\begin{equation}
    F^{-} = E_y - c B_z
\end{equation}
Analogicznie, dla składowych $E_z$, $B_y$:

% TODO: zweryfikować znaki i czy c nie jest w mianowniku
\begin{equation}
    G^{+} = E_z - c B_y
\end{equation}
\begin{equation}
    G^{-} = E_z + c B_y
\end{equation}

\subsection{Implementacja podstawowych algorytmów numerycznych stosowanych w symulacji}

\subsection{Wykorzystane techniki i technologie}
\begin{itemize}
    \item obliczenia wektorowe
    \item pytest; Test-driven development
    \item format plików danych hdf5
    \item wykresy: matplotlib
    \item scipy
    \item numba
    \item numpy
\end{itemize}

Przy pracy nad kodem użyto frameworku testowego pytest %link w stopce
Obsługa testów jest trywialna:

Należy zaznaczyć, że w numeryce testy jednostkowe potrafią zaoszczędzić bardzo dużo czasu na polowaniach na bugi
poprzez automatyzację uruchamiania kolejnych partii kodu. Dobrze napisane testy są praktycznie koniecznością w dzisiejszych
czasach. % trochę soapbox?
% przykład kodu
% powinienem mieć coś w stylu make test czy setup.py test

\subsubsection{Numba}
Innym podejściem do optymalizacji kodu napisanego w Pythonie jest kompilacja Just-In-Time, polegająca na % TODO: JIT
