\section[Wnioski]{Wnioski}\label{sec:ending} % 3-5 stron
% 6. Zakończenia – będącego krótkim podsumowaniem realizacji pracy i
% rozwiązywanego zadania inżynierskiego. Zakończenie powinno zawierać:
% prezentację wniosków, odniesienie do poszczególnych rozdziałów pracy a także
% wskazanie na ew. rekomendowane kierunki dalszych prac nad podjętym zadaniem
% inżynierskim.
% 6. Zakończenie - 3-5 stron - Ponowna krótka prezentacja wyników podsumowująca
%   pracę z licznymi odniesieniami do rozdziałów pracy

W niniejszej pracy opisano proces tworzenia kodu symulacyjnego implementującego
algorytm particle-in-cell. W rozdziale~\ref{sec:theory} wyjaśniono zasadność modelowania plazmy symulacjami komputerowymi oraz zasadność przyjętego przybliżenia
% TODO CZY JA WYJAŚNIŁEM ZASADNOŚĆ PRZYJĘTEGO PRZYBLIŻENIA NA PODSTAWIE BIRDSALLA INTRO?
modelowania plazmy dyskretnymi cząstkami. Poszczególne elementy realizacji algorytmu particle-in-cell w bieżącym kodzie wyjaśniono w rozdziale~\ref{sec:implementation}.

W rozdziale~\ref{sec:code} opisano ekosystem Pythona, jego potencjał dla nauki i symulacji numerycznej, a także strukturę i hierarchię samego kodu, który jest przedmiotem bieżącej pracy.

Z dobrą zgodnością z zakładanym modelem udało się wykonać symulację zachowania plazmy pobudzonej wysokoenergetycznym impulsem laserowym. %TODO

%Wyniki benchmarków pokazują,% TODO

\subsection{Potencjalne kierunki dalszej pracy}

Program w obecnej postaci działa w jednym wymiarze, w reżimie relatywistycznym i jako taki może służyć do prostego modelowania oddziaływania plazmy z wiązkami laserowymi
bądź do modelowania niestabilności w symulacjach elektrostatycznych.

Oczywistym kierunkiem rozwoju dla kodu jest dodanie obsługi ruchu cząstek w wielu wymiarach. Wymagałoby to niestety znacznej zmiany modelu rozwiązywania równań ewolucji czasowej pola elektromagnetycznego.
Warunki początkowe można zaadaptować z pola elektrostatycznego, aczkolwiek gdy układ straci symetrię $\frac{\partial}{\partial y} = \frac{\partial}{\partial z} = 0$, będzie konieczne również rozwiązywanie
prawa Gaussa dla magnetyzmu~\ref{eqn:maxwell-B-div}.

Kolejnym potencjalnym krokiem byłoby wykorzystanie mocy obliczeniowej kart graficznych. Potencjalnym kandydatem do tego celu byłoby wykorzystanie popularnej biblioteki \code{PyCUDA}.
Alternatywnym sposobem zrównoleglenia kodu byłoby wykorzystanie paradygmatu OpenMP/MPI, do czego może posłużyć biblioteka \code{MPI4PY}.

Symulacja nie uwzględnia również kolizji. Możliwe jest dodanie ich na przykład poprzez sprzężenie algorytmu z implementacją DSMC (\english{Direct Simulation Monte Carlo})~\cite{particleincell-dmsc}. %TODO poczytać o MC

W bieżącej symulacji użyto prostego modelu pojedynczo zjonizowanych atomów wodoru bez możliwości syntezy w neutralne cząstki wodoru. Istnieje możliwość wybrania atomów innych pierwiastków,
lecz w chwili obecnej kod zupełnie nie uwzględnia możliwości dalszej jonizacji tych cząstek.




% szerzej opisany w rozdziałach~\ref{sec:theory} i~\ref{sec:implementation}.
%Wykorzystano wysokopoziomowy język Python, opisany w rozdziale~\ref{sec:theory}.



%Utworzono kod symulacyjny implementujący algorytm particle-in-cell w Pythonie przy użyciu wszystkich dostępnych
%możliwości, jakie daje ekosystem open-source. Kod zoptymalizowano przy użyciu 
%Otrzymane wyniki benchmarków pozwalają sądzić, że \todo[inline]



